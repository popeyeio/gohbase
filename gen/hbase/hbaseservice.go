// Autogenerated by Thrift Compiler (0.9.2)
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING

package hbase

import (
	"bytes"
	"context"
	"fmt"

	"github.com/popeyeio/gohbase/lib/thrift"
)

// (needed to ensure safety because of naive import list construction.)
var _ = thrift.ZERO
var _ = fmt.Printf
var _ = bytes.Equal

type Hbase interface {
	// Brings a table on-line (enables it)
	//
	// Parameters:
	//  - TableName: name of the table
	EnableTable(tableName Bytes) (err error)
	// Disables a table (takes it off-line) If it is being served, the master
	// will tell the servers to stop serving it.
	//
	// Parameters:
	//  - TableName: name of the table
	DisableTable(tableName Bytes) (err error)
	// @return true if table is on-line
	//
	// Parameters:
	//  - TableName: name of the table to check
	IsTableEnabled(tableName Bytes) (r bool, err error)
	// Parameters:
	//  - TableNameOrRegionName
	Compact(tableNameOrRegionName Bytes) (err error)
	// Parameters:
	//  - TableNameOrRegionName
	MajorCompact(tableNameOrRegionName Bytes) (err error)
	// List all the userspace tables.
	//
	// @return returns a list of names
	GetTableNames() (r [][]byte, err error)
	// List all the column families assoicated with a table.
	//
	// @return list of column family descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetColumnDescriptors(tableName Text) (r map[string]*ColumnDescriptor, err error)
	// List the regions associated with a table.
	//
	// @return list of region descriptors
	//
	// Parameters:
	//  - TableName: table name
	GetTableRegions(tableName Text) (r []*TRegionInfo, err error)
	// Create a table with the specified column families.  The name
	// field for each ColumnDescriptor must be set and must end in a
	// colon (:). All other fields are optional and will get default
	// values if not explicitly specified.
	//
	// @throws IllegalArgument if an input parameter is invalid
	//
	// @throws AlreadyExists if the table name already exists
	//
	// Parameters:
	//  - TableName: name of table to create
	//  - ColumnFamilies: list of column family descriptors
	CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error)
	// Deletes a table
	//
	// @throws IOError if table doesn't exist on server or there was some other
	// problem
	//
	// Parameters:
	//  - TableName: name of table to delete
	DeleteTable(tableName Text) (err error)
	// Get a single TCell for the specified table, row, and column at the
	// latest timestamp. Returns an empty list if no such value exists.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Attributes: Get attributes
	Get(tableName Text, row Text, column Text, attributes map[string]Text) (r []*TCell, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (r []*TCell, err error)
	// Get the specified number of versions for the specified table,
	// row, and column.  Only versions less than or equal to the specified
	// timestamp will be returned.
	//
	// @return list of cells for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Timestamp: timestamp
	//  - NumVersions: number of versions to retrieve
	//  - Attributes: Get attributes
	GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (r []*TCell, err error)
	// Get all the data for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Attributes: Get attributes
	GetRow(tableName Text, row Text, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and row at the latest
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowWithColumns(tableName Text, row Text, columns [][]byte, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Row: row key
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and row at the specified
	// timestamp. Returns an empty list if the row does not exist.
	//
	// @return TRowResult containing the row and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowWithColumnsTs(tableName Text, row Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Attributes: Get attributes
	GetRows(tableName Text, rows [][]byte, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and rows at the latest
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Attributes: Get attributes
	GetRowsWithColumns(tableName Text, rows [][]byte, columns [][]byte, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get all the data for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of the table
	//  - Rows: row keys
	//  - Timestamp: timestamp
	//  - Attributes: Get attributes
	GetRowsTs(tableName Text, rows [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Get the specified columns for the specified table and rows at the specified
	// timestamp. Returns an empty list if no rows exist.
	//
	// @return TRowResult containing the rows and map of columns to TCells
	//
	// Parameters:
	//  - TableName: name of table
	//  - Rows: row keys
	//  - Columns: List of columns to return, null for all columns
	//  - Timestamp
	//  - Attributes: Get attributes
	GetRowsWithColumnsTs(tableName Text, rows [][]byte, columns [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Attributes: Mutation attributes
	MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error)
	// Apply a series of mutations (updates/deletes) to a row in a
	// single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Mutations: list of mutation commands
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  Default current timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Attributes: Mutation attributes
	MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error)
	// Apply a series of batches (each a series of mutations on a single row)
	// in a single transaction.  If an exception is thrown, then the
	// transaction is aborted.  The specified timestamp is used, and
	// all entries will have an identical timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - RowBatches: list of row batches
	//  - Timestamp: timestamp
	//  - Attributes: Mutation attributes
	MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error)
	// Atomically increment the column value specified.  Returns the next value post increment.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row to increment
	//  - Column: name of column
	//  - Value: amount to increment by
	AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, err error)
	// Delete all cells that match the passed row and column.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Attributes: Delete attributes
	DeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error)
	// Delete all cells that match the passed row and column and whose
	// timestamp is equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: Row to update
	//  - Column: name of column whose value is to be deleted
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error)
	// Completely delete the row's cells.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Attributes: Delete attributes
	DeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error)
	// Increment a cell by the ammount.
	// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
	// False is the default.  Turn to true if you need the extra performance and can accept some
	// data loss if a thrift server dies with increments still in the queue.
	//
	// Parameters:
	//  - Increment: The single increment to apply
	Increment(increment *TIncrement) (err error)
	// Parameters:
	//  - Increments: The list of increments
	IncrementRows(increments []*TIncrement) (err error)
	// Completely delete the row's cells marked with a timestamp
	// equal-to or older than the passed timestamp.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: key of the row to be completely deleted.
	//  - Timestamp: timestamp
	//  - Attributes: Delete attributes
	DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error)
	// Get a scanner on the current table, using the Scan instance
	// for the scan parameters.
	//
	// Parameters:
	//  - TableName: name of table
	//  - Scan: Scan instance
	//  - Attributes: Scan attributes
	ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpen(tableName Text, startRow Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Attributes: Scan attributes
	ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error)
	// Open a scanner for a given prefix.  That is all rows will have the specified
	// prefix. No other rows will be returned.
	//
	// @return scanner id to use with other scanner calls
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
	//  - Columns: the columns you want returned
	//  - Attributes: Scan attributes
	ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting at the specified row and
	// ending at the last row in the table.  Return the specified columns.
	// Only values with the specified timestamp are returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenTs(tableName Text, startRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r ScannerID, err error)
	// Get a scanner on the current table starting and stopping at the
	// specified rows.  ending at the last row in the table.  Return the
	// specified columns.  Only values with the specified timestamp are
	// returned.
	//
	// @return scanner id to be used with other scanner procedures
	//
	// Parameters:
	//  - TableName: name of table
	//  - StartRow: Starting row in table to scan.
	// Send "" (empty string) to start at the first row.
	//  - StopRow: row to stop scanning on. This row is *not* included in the
	// scanner's results
	//  - Columns: columns to scan. If column name is a column family, all
	// columns of the specified column family are returned. It's also possible
	// to pass a regex in the column qualifier.
	//  - Timestamp: timestamp
	//  - Attributes: Scan attributes
	ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r ScannerID, err error)
	// Returns the scanner's current row value and advances to the next
	// row in the table.  When there are no more rows in the table, or a key
	// greater-than-or-equal-to the scanner's specified stopRow is reached,
	// an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerGet(id ScannerID) (r []*TRowResult_, err error)
	// Returns, starting at the scanner's current row value nbRows worth of
	// rows and advances to the next row in the table.  When there are no more
	// rows in the table, or a key greater-than-or-equal-to the scanner's
	// specified stopRow is reached,  an empty list is returned.
	//
	// @return a TRowResult containing the current row and a map of the columns to TCells.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// @throws NotFound when the scanner reaches the end
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	//  - NbRows: number of results to return
	ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult_, err error)
	// Closes the server-state associated with an open scanner.
	//
	// @throws IllegalArgument if ScannerID is invalid
	//
	// Parameters:
	//  - Id: id of a scanner returned by scannerOpen
	ScannerClose(id ScannerID) (err error)
	// Get the row just before the specified one.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Family: column name
	GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, err error)
	// Get the regininfo for the specified row. It scans
	// the metatable to find region's start and end keys.
	//
	// @return value for specified row/column
	//
	// Parameters:
	//  - Row: row key
	GetRegionInfo(row Text) (r *TRegionInfo, err error)
	// Appends values to one or more columns within a single row.
	//
	// @return values of columns after the append operation.
	//
	// Parameters:
	//  - Append: The single append operation to apply
	Append(append *TAppend) (r []*TCell, err error)
	// Atomically checks if a row/family/qualifier value matches the expected
	// value. If it does, it adds the corresponding mutation operation for put.
	//
	// @return true if the new put was executed, false otherwise
	//
	// Parameters:
	//  - TableName: name of table
	//  - Row: row key
	//  - Column: column name
	//  - Value: the expected value for the column parameter, if not
	// provided the check is for the non-existence of the
	// column in question
	//  - Mput: mutation for the put
	//  - Attributes: Mutation attributes
	CheckAndPut(tableName Text, row Text, column Text, value Text, mput *Mutation, attributes map[string]Text) (r bool, err error)
}

type HbaseClient struct {
	Transport       thrift.TTransport
	ProtocolFactory thrift.TProtocolFactory
	InputProtocol   thrift.TProtocol
	OutputProtocol  thrift.TProtocol
	SeqId           int32
}

func NewHbaseClientFactory(t thrift.TTransport, f thrift.TProtocolFactory) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: f,
		InputProtocol:   f.GetProtocol(t),
		OutputProtocol:  f.GetProtocol(t),
		SeqId:           0,
	}
}

func NewHbaseClientProtocol(t thrift.TTransport, iprot thrift.TProtocol, oprot thrift.TProtocol) *HbaseClient {
	return &HbaseClient{Transport: t,
		ProtocolFactory: nil,
		InputProtocol:   iprot,
		OutputProtocol:  oprot,
		SeqId:           0,
	}
}

// Brings a table on-line (enables it)
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) EnableTable(tableName Bytes) (err error) {
	if err = p.sendEnableTable(tableName); err != nil {
		return
	}
	return p.recvEnableTable()
}

func (p *HbaseClient) sendEnableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("enableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := EnableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvEnableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "enableTable failed: out of sequence response")
		return
	}
	result := EnableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Disables a table (takes it off-line) If it is being served, the master
// will tell the servers to stop serving it.
//
// Parameters:
//  - TableName: name of the table
func (p *HbaseClient) DisableTable(tableName Bytes) (err error) {
	if err = p.sendDisableTable(tableName); err != nil {
		return
	}
	return p.recvDisableTable()
}

func (p *HbaseClient) sendDisableTable(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("disableTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DisableTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDisableTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "disableTable failed: out of sequence response")
		return
	}
	result := DisableTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// @return true if table is on-line
//
// Parameters:
//  - TableName: name of the table to check
func (p *HbaseClient) IsTableEnabled(tableName Bytes) (r bool, err error) {
	if err = p.sendIsTableEnabled(tableName); err != nil {
		return
	}
	return p.recvIsTableEnabled()
}

func (p *HbaseClient) sendIsTableEnabled(tableName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("isTableEnabled", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IsTableEnabledArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvIsTableEnabled() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "isTableEnabled failed: out of sequence response")
		return
	}
	result := IsTableEnabledResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) Compact(tableNameOrRegionName Bytes) (err error) {
	if err = p.sendCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvCompact()
}

func (p *HbaseClient) sendCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("compact", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CompactArgs{
		TableNameOrRegionName: tableNameOrRegionName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvCompact() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "compact failed: out of sequence response")
		return
	}
	result := CompactResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Parameters:
//  - TableNameOrRegionName
func (p *HbaseClient) MajorCompact(tableNameOrRegionName Bytes) (err error) {
	if err = p.sendMajorCompact(tableNameOrRegionName); err != nil {
		return
	}
	return p.recvMajorCompact()
}

func (p *HbaseClient) sendMajorCompact(tableNameOrRegionName Bytes) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("majorCompact", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MajorCompactArgs{
		TableNameOrRegionName: tableNameOrRegionName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvMajorCompact() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "majorCompact failed: out of sequence response")
		return
	}
	result := MajorCompactResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// List all the userspace tables.
//
// @return returns a list of names
func (p *HbaseClient) GetTableNames() (r [][]byte, err error) {
	if err = p.sendGetTableNames(); err != nil {
		return
	}
	return p.recvGetTableNames()
}

func (p *HbaseClient) sendGetTableNames() (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableNames", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTableNamesArgs{}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetTableNames() (value [][]byte, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableNames failed: out of sequence response")
		return
	}
	result := GetTableNamesResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// List all the column families assoicated with a table.
//
// @return list of column family descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetColumnDescriptors(tableName Text) (r map[string]*ColumnDescriptor, err error) {
	if err = p.sendGetColumnDescriptors(tableName); err != nil {
		return
	}
	return p.recvGetColumnDescriptors()
}

func (p *HbaseClient) sendGetColumnDescriptors(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getColumnDescriptors", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetColumnDescriptorsArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetColumnDescriptors() (value map[string]*ColumnDescriptor, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getColumnDescriptors failed: out of sequence response")
		return
	}
	result := GetColumnDescriptorsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// List the regions associated with a table.
//
// @return list of region descriptors
//
// Parameters:
//  - TableName: table name
func (p *HbaseClient) GetTableRegions(tableName Text) (r []*TRegionInfo, err error) {
	if err = p.sendGetTableRegions(tableName); err != nil {
		return
	}
	return p.recvGetTableRegions()
}

func (p *HbaseClient) sendGetTableRegions(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getTableRegions", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetTableRegionsArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetTableRegions() (value []*TRegionInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getTableRegions failed: out of sequence response")
		return
	}
	result := GetTableRegionsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Create a table with the specified column families.  The name
// field for each ColumnDescriptor must be set and must end in a
// colon (:). All other fields are optional and will get default
// values if not explicitly specified.
//
// @throws IllegalArgument if an input parameter is invalid
//
// @throws AlreadyExists if the table name already exists
//
// Parameters:
//  - TableName: name of table to create
//  - ColumnFamilies: list of column family descriptors
func (p *HbaseClient) CreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error) {
	if err = p.sendCreateTable(tableName, columnFamilies); err != nil {
		return
	}
	return p.recvCreateTable()
}

func (p *HbaseClient) sendCreateTable(tableName Text, columnFamilies []*ColumnDescriptor) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("createTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CreateTableArgs{
		TableName:      tableName,
		ColumnFamilies: columnFamilies,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvCreateTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "createTable failed: out of sequence response")
		return
	}
	result := CreateTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	} else if result.Exist != nil {
		err = result.Exist
		return
	}
	return
}

// Deletes a table
//
// @throws IOError if table doesn't exist on server or there was some other
// problem
//
// Parameters:
//  - TableName: name of table to delete
func (p *HbaseClient) DeleteTable(tableName Text) (err error) {
	if err = p.sendDeleteTable(tableName); err != nil {
		return
	}
	return p.recvDeleteTable()
}

func (p *HbaseClient) sendDeleteTable(tableName Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteTable", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteTableArgs{
		TableName: tableName,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDeleteTable() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteTable failed: out of sequence response")
		return
	}
	result := DeleteTableResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get a single TCell for the specified table, row, and column at the
// latest timestamp. Returns an empty list if no such value exists.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Attributes: Get attributes
func (p *HbaseClient) Get(tableName Text, row Text, column Text, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGet(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvGet()
}

func (p *HbaseClient) sendGet(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("get", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetArgs{
		TableName:  tableName,
		Row:        row,
		Column:     column,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGet() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "get failed: out of sequence response")
		return
	}
	result := GetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified number of versions for the specified table,
// row, and column.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGetVer(tableName, row, column, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVer()
}

func (p *HbaseClient) sendGetVer(tableName Text, row Text, column Text, numVersions int32, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getVer", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetVerArgs{
		TableName:   tableName,
		Row:         row,
		Column:      column,
		NumVersions: numVersions,
		Attributes:  attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetVer() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getVer failed: out of sequence response")
		return
	}
	result := GetVerResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified number of versions for the specified table,
// row, and column.  Only versions less than or equal to the specified
// timestamp will be returned.
//
// @return list of cells for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Timestamp: timestamp
//  - NumVersions: number of versions to retrieve
//  - Attributes: Get attributes
func (p *HbaseClient) GetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (r []*TCell, err error) {
	if err = p.sendGetVerTs(tableName, row, column, timestamp, numVersions, attributes); err != nil {
		return
	}
	return p.recvGetVerTs()
}

func (p *HbaseClient) sendGetVerTs(tableName Text, row Text, column Text, timestamp int64, numVersions int32, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getVerTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetVerTsArgs{
		TableName:   tableName,
		Row:         row,
		Column:      column,
		Timestamp:   timestamp,
		NumVersions: numVersions,
		Attributes:  attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetVerTs() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getVerTs failed: out of sequence response")
		return
	}
	result := GetVerTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all the data for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Attributes: Get attributes
func (p *HbaseClient) GetRow(tableName Text, row Text, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvGetRow()
}

func (p *HbaseClient) sendGetRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowArgs{
		TableName:  tableName,
		Row:        row,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRow() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRow failed: out of sequence response")
		return
	}
	result := GetRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified columns for the specified table and row at the latest
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumns(tableName Text, row Text, columns [][]byte, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowWithColumns(tableName, row, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumns()
}

func (p *HbaseClient) sendGetRowWithColumns(tableName Text, row Text, columns [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowWithColumns", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowWithColumnsArgs{
		TableName:  tableName,
		Row:        row,
		Columns:    columns,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowWithColumns() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowWithColumns failed: out of sequence response")
		return
	}
	result := GetRowWithColumnsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all the data for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Row: row key
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowTs()
}

func (p *HbaseClient) sendGetRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowTsArgs{
		TableName:  tableName,
		Row:        row,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowTs failed: out of sequence response")
		return
	}
	result := GetRowTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified columns for the specified table and row at the specified
// timestamp. Returns an empty list if the row does not exist.
//
// @return TRowResult containing the row and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowWithColumnsTs(tableName Text, row Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowWithColumnsTs(tableName, row, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowWithColumnsTs()
}

func (p *HbaseClient) sendGetRowWithColumnsTs(tableName Text, row Text, columns [][]byte, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowWithColumnsTsArgs{
		TableName:  tableName,
		Row:        row,
		Columns:    columns,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowWithColumnsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowWithColumnsTs failed: out of sequence response")
		return
	}
	result := GetRowWithColumnsTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all the data for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Attributes: Get attributes
func (p *HbaseClient) GetRows(tableName Text, rows [][]byte, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRows(tableName, rows, attributes); err != nil {
		return
	}
	return p.recvGetRows()
}

func (p *HbaseClient) sendGetRows(tableName Text, rows [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowsArgs{
		TableName:  tableName,
		Rows:       rows,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRows() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRows failed: out of sequence response")
		return
	}
	result := GetRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified columns for the specified table and rows at the latest
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumns(tableName Text, rows [][]byte, columns [][]byte, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsWithColumns(tableName, rows, columns, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumns()
}

func (p *HbaseClient) sendGetRowsWithColumns(tableName Text, rows [][]byte, columns [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsWithColumns", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowsWithColumnsArgs{
		TableName:  tableName,
		Rows:       rows,
		Columns:    columns,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowsWithColumns() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsWithColumns failed: out of sequence response")
		return
	}
	result := GetRowsWithColumnsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get all the data for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of the table
//  - Rows: row keys
//  - Timestamp: timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsTs(tableName Text, rows [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsTs(tableName, rows, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsTs()
}

func (p *HbaseClient) sendGetRowsTs(tableName Text, rows [][]byte, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowsTsArgs{
		TableName:  tableName,
		Rows:       rows,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsTs failed: out of sequence response")
		return
	}
	result := GetRowsTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the specified columns for the specified table and rows at the specified
// timestamp. Returns an empty list if no rows exist.
//
// @return TRowResult containing the rows and map of columns to TCells
//
// Parameters:
//  - TableName: name of table
//  - Rows: row keys
//  - Columns: List of columns to return, null for all columns
//  - Timestamp
//  - Attributes: Get attributes
func (p *HbaseClient) GetRowsWithColumnsTs(tableName Text, rows [][]byte, columns [][]byte, timestamp int64, attributes map[string]Text) (r []*TRowResult_, err error) {
	if err = p.sendGetRowsWithColumnsTs(tableName, rows, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvGetRowsWithColumnsTs()
}

func (p *HbaseClient) sendGetRowsWithColumnsTs(tableName Text, rows [][]byte, columns [][]byte, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowsWithColumnsTsArgs{
		TableName:  tableName,
		Rows:       rows,
		Columns:    columns,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowsWithColumnsTs() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowsWithColumnsTs failed: out of sequence response")
		return
	}
	result := GetRowsWithColumnsTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error) {
	if err = p.sendMutateRow(tableName, row, mutations, attributes); err != nil {
		return
	}
	return p.recvMutateRow()
}

func (p *HbaseClient) sendMutateRow(tableName Text, row Text, mutations []*Mutation, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MutateRowArgs{
		TableName:  tableName,
		Row:        row,
		Mutations:  mutations,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvMutateRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRow failed: out of sequence response")
		return
	}
	result := MutateRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// Apply a series of mutations (updates/deletes) to a row in a
// single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Mutations: list of mutation commands
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendMutateRowTs(tableName, row, mutations, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowTs()
}

func (p *HbaseClient) sendMutateRowTs(tableName Text, row Text, mutations []*Mutation, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MutateRowTsArgs{
		TableName:  tableName,
		Row:        row,
		Mutations:  mutations,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvMutateRowTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRowTs failed: out of sequence response")
		return
	}
	result := MutateRowTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  Default current timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error) {
	if err = p.sendMutateRows(tableName, rowBatches, attributes); err != nil {
		return
	}
	return p.recvMutateRows()
}

func (p *HbaseClient) sendMutateRows(tableName Text, rowBatches []*BatchMutation, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MutateRowsArgs{
		TableName:  tableName,
		RowBatches: rowBatches,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvMutateRows() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRows failed: out of sequence response")
		return
	}
	result := MutateRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// Apply a series of batches (each a series of mutations on a single row)
// in a single transaction.  If an exception is thrown, then the
// transaction is aborted.  The specified timestamp is used, and
// all entries will have an identical timestamp.
//
// Parameters:
//  - TableName: name of table
//  - RowBatches: list of row batches
//  - Timestamp: timestamp
//  - Attributes: Mutation attributes
func (p *HbaseClient) MutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendMutateRowsTs(tableName, rowBatches, timestamp, attributes); err != nil {
		return
	}
	return p.recvMutateRowsTs()
}

func (p *HbaseClient) sendMutateRowsTs(tableName Text, rowBatches []*BatchMutation, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("mutateRowsTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := MutateRowsTsArgs{
		TableName:  tableName,
		RowBatches: rowBatches,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvMutateRowsTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "mutateRowsTs failed: out of sequence response")
		return
	}
	result := MutateRowsTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// Atomically increment the column value specified.  Returns the next value post increment.
//
// Parameters:
//  - TableName: name of table
//  - Row: row to increment
//  - Column: name of column
//  - Value: amount to increment by
func (p *HbaseClient) AtomicIncrement(tableName Text, row Text, column Text, value int64) (r int64, err error) {
	if err = p.sendAtomicIncrement(tableName, row, column, value); err != nil {
		return
	}
	return p.recvAtomicIncrement()
}

func (p *HbaseClient) sendAtomicIncrement(tableName Text, row Text, column Text, value int64) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("atomicIncrement", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AtomicIncrementArgs{
		TableName: tableName,
		Row:       row,
		Column:    column,
		Value:     value,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvAtomicIncrement() (value int64, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "atomicIncrement failed: out of sequence response")
		return
	}
	result := AtomicIncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Delete all cells that match the passed row and column.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAll(tableName, row, column, attributes); err != nil {
		return
	}
	return p.recvDeleteAll()
}

func (p *HbaseClient) sendDeleteAll(tableName Text, row Text, column Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAll", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteAllArgs{
		TableName:  tableName,
		Row:        row,
		Column:     column,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDeleteAll() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAll failed: out of sequence response")
		return
	}
	result := DeleteAllResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Delete all cells that match the passed row and column and whose
// timestamp is equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: Row to update
//  - Column: name of column whose value is to be deleted
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllTs(tableName, row, column, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllTs()
}

func (p *HbaseClient) sendDeleteAllTs(tableName Text, row Text, column Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteAllTsArgs{
		TableName:  tableName,
		Row:        row,
		Column:     column,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDeleteAllTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllTs failed: out of sequence response")
		return
	}
	result := DeleteAllTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Completely delete the row's cells.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllRow(tableName, row, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRow()
}

func (p *HbaseClient) sendDeleteAllRow(tableName Text, row Text, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllRow", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteAllRowArgs{
		TableName:  tableName,
		Row:        row,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDeleteAllRow() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllRow failed: out of sequence response")
		return
	}
	result := DeleteAllRowResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Increment a cell by the ammount.
// Increments can be applied async if hbase.regionserver.thrift.coalesceIncrement is set to true.
// False is the default.  Turn to true if you need the extra performance and can accept some
// data loss if a thrift server dies with increments still in the queue.
//
// Parameters:
//  - Increment: The single increment to apply
func (p *HbaseClient) Increment(increment *TIncrement) (err error) {
	if err = p.sendIncrement(increment); err != nil {
		return
	}
	return p.recvIncrement()
}

func (p *HbaseClient) sendIncrement(increment *TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("increment", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IncrementArgs{
		Increment: increment,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvIncrement() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "increment failed: out of sequence response")
		return
	}
	result := IncrementResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Parameters:
//  - Increments: The list of increments
func (p *HbaseClient) IncrementRows(increments []*TIncrement) (err error) {
	if err = p.sendIncrementRows(increments); err != nil {
		return
	}
	return p.recvIncrementRows()
}

func (p *HbaseClient) sendIncrementRows(increments []*TIncrement) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("incrementRows", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := IncrementRowsArgs{
		Increments: increments,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvIncrementRows() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "incrementRows failed: out of sequence response")
		return
	}
	result := IncrementRowsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Completely delete the row's cells marked with a timestamp
// equal-to or older than the passed timestamp.
//
// Parameters:
//  - TableName: name of table
//  - Row: key of the row to be completely deleted.
//  - Timestamp: timestamp
//  - Attributes: Delete attributes
func (p *HbaseClient) DeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	if err = p.sendDeleteAllRowTs(tableName, row, timestamp, attributes); err != nil {
		return
	}
	return p.recvDeleteAllRowTs()
}

func (p *HbaseClient) sendDeleteAllRowTs(tableName Text, row Text, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("deleteAllRowTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := DeleteAllRowTsArgs{
		TableName:  tableName,
		Row:        row,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvDeleteAllRowTs() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "deleteAllRowTs failed: out of sequence response")
		return
	}
	result := DeleteAllRowTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	return
}

// Get a scanner on the current table, using the Scan instance
// for the scan parameters.
//
// Parameters:
//  - TableName: name of table
//  - Scan: Scan instance
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithScan(tableName, scan, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithScan()
}

func (p *HbaseClient) sendScannerOpenWithScan(tableName Text, scan *TScan, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithScan", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenWithScanArgs{
		TableName:  tableName,
		Scan:       scan,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpenWithScan() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithScan failed: out of sequence response")
		return
	}
	result := ScannerOpenWithScanResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpen(tableName Text, startRow Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpen(tableName, startRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpen()
}

func (p *HbaseClient) sendScannerOpen(tableName Text, startRow Text, columns [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpen", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenArgs{
		TableName:  tableName,
		StartRow:   startRow,
		Columns:    columns,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpen() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpen failed: out of sequence response")
		return
	}
	result := ScannerOpenResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithStop(tableName, startRow, stopRow, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStop()
}

func (p *HbaseClient) sendScannerOpenWithStop(tableName Text, startRow Text, stopRow Text, columns [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithStop", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenWithStopArgs{
		TableName:  tableName,
		StartRow:   startRow,
		StopRow:    stopRow,
		Columns:    columns,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpenWithStop() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithStop failed: out of sequence response")
		return
	}
	result := ScannerOpenWithStopResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Open a scanner for a given prefix.  That is all rows will have the specified
// prefix. No other rows will be returned.
//
// @return scanner id to use with other scanner calls
//
// Parameters:
//  - TableName: name of table
//  - StartAndPrefix: the prefix (and thus start row) of the keys you want
//  - Columns: the columns you want returned
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns [][]byte, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithPrefix(tableName, startAndPrefix, columns, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithPrefix()
}

func (p *HbaseClient) sendScannerOpenWithPrefix(tableName Text, startAndPrefix Text, columns [][]byte, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenWithPrefixArgs{
		TableName:      tableName,
		StartAndPrefix: startAndPrefix,
		Columns:        columns,
		Attributes:     attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpenWithPrefix() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithPrefix failed: out of sequence response")
		return
	}
	result := ScannerOpenWithPrefixResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a scanner on the current table starting at the specified row and
// ending at the last row in the table.  Return the specified columns.
// Only values with the specified timestamp are returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenTs(tableName Text, startRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenTs(tableName, startRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenTs()
}

func (p *HbaseClient) sendScannerOpenTs(tableName Text, startRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenTsArgs{
		TableName:  tableName,
		StartRow:   startRow,
		Columns:    columns,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpenTs() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenTs failed: out of sequence response")
		return
	}
	result := ScannerOpenTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get a scanner on the current table starting and stopping at the
// specified rows.  ending at the last row in the table.  Return the
// specified columns.  Only values with the specified timestamp are
// returned.
//
// @return scanner id to be used with other scanner procedures
//
// Parameters:
//  - TableName: name of table
//  - StartRow: Starting row in table to scan.
// Send "" (empty string) to start at the first row.
//  - StopRow: row to stop scanning on. This row is *not* included in the
// scanner's results
//  - Columns: columns to scan. If column name is a column family, all
// columns of the specified column family are returned. It's also possible
// to pass a regex in the column qualifier.
//  - Timestamp: timestamp
//  - Attributes: Scan attributes
func (p *HbaseClient) ScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (r ScannerID, err error) {
	if err = p.sendScannerOpenWithStopTs(tableName, startRow, stopRow, columns, timestamp, attributes); err != nil {
		return
	}
	return p.recvScannerOpenWithStopTs()
}

func (p *HbaseClient) sendScannerOpenWithStopTs(tableName Text, startRow Text, stopRow Text, columns [][]byte, timestamp int64, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerOpenWithStopTsArgs{
		TableName:  tableName,
		StartRow:   startRow,
		StopRow:    stopRow,
		Columns:    columns,
		Timestamp:  timestamp,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerOpenWithStopTs() (value ScannerID, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerOpenWithStopTs failed: out of sequence response")
		return
	}
	result := ScannerOpenWithStopTsResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Returns the scanner's current row value and advances to the next
// row in the table.  When there are no more rows in the table, or a key
// greater-than-or-equal-to the scanner's specified stopRow is reached,
// an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerGet(id ScannerID) (r []*TRowResult_, err error) {
	if err = p.sendScannerGet(id); err != nil {
		return
	}
	return p.recvScannerGet()
}

func (p *HbaseClient) sendScannerGet(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerGet", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerGetArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerGet() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerGet failed: out of sequence response")
		return
	}
	result := ScannerGetResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Returns, starting at the scanner's current row value nbRows worth of
// rows and advances to the next row in the table.  When there are no more
// rows in the table, or a key greater-than-or-equal-to the scanner's
// specified stopRow is reached,  an empty list is returned.
//
// @return a TRowResult containing the current row and a map of the columns to TCells.
//
// @throws IllegalArgument if ScannerID is invalid
//
// @throws NotFound when the scanner reaches the end
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
//  - NbRows: number of results to return
func (p *HbaseClient) ScannerGetList(id ScannerID, nbRows int32) (r []*TRowResult_, err error) {
	if err = p.sendScannerGetList(id, nbRows); err != nil {
		return
	}
	return p.recvScannerGetList()
}

func (p *HbaseClient) sendScannerGetList(id ScannerID, nbRows int32) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerGetList", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerGetListArgs{
		Id:     id,
		NbRows: nbRows,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerGetList() (value []*TRowResult_, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerGetList failed: out of sequence response")
		return
	}
	result := ScannerGetListResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

// Closes the server-state associated with an open scanner.
//
// @throws IllegalArgument if ScannerID is invalid
//
// Parameters:
//  - Id: id of a scanner returned by scannerOpen
func (p *HbaseClient) ScannerClose(id ScannerID) (err error) {
	if err = p.sendScannerClose(id); err != nil {
		return
	}
	return p.recvScannerClose()
}

func (p *HbaseClient) sendScannerClose(id ScannerID) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("scannerClose", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := ScannerCloseArgs{
		Id: id,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvScannerClose() (err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "scannerClose failed: out of sequence response")
		return
	}
	result := ScannerCloseResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	return
}

// Get the row just before the specified one.
//
// @return value for specified row/column
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Family: column name
func (p *HbaseClient) GetRowOrBefore(tableName Text, row Text, family Text) (r []*TCell, err error) {
	if err = p.sendGetRowOrBefore(tableName, row, family); err != nil {
		return
	}
	return p.recvGetRowOrBefore()
}

func (p *HbaseClient) sendGetRowOrBefore(tableName Text, row Text, family Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRowOrBefore", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRowOrBeforeArgs{
		TableName: tableName,
		Row:       row,
		Family:    family,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRowOrBefore() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRowOrBefore failed: out of sequence response")
		return
	}
	result := GetRowOrBeforeResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Get the regininfo for the specified row. It scans
// the metatable to find region's start and end keys.
//
// @return value for specified row/column
//
// Parameters:
//  - Row: row key
func (p *HbaseClient) GetRegionInfo(row Text) (r *TRegionInfo, err error) {
	if err = p.sendGetRegionInfo(row); err != nil {
		return
	}
	return p.recvGetRegionInfo()
}

func (p *HbaseClient) sendGetRegionInfo(row Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("getRegionInfo", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := GetRegionInfoArgs{
		Row: row,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvGetRegionInfo() (value *TRegionInfo, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error5 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error5.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "getRegionInfo failed: out of sequence response")
		return
	}
	result := GetRegionInfoResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Appends values to one or more columns within a single row.
//
// @return values of columns after the append operation.
//
// Parameters:
//  - Append: The single append operation to apply
func (p *HbaseClient) Append(append *TAppend) (r []*TCell, err error) {
	if err = p.sendAppend(append); err != nil {
		return
	}
	return p.recvAppend()
}

func (p *HbaseClient) sendAppend(append *TAppend) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("append", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := AppendArgs{
		Append: append,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvAppend() (value []*TCell, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error93 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error93.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "append failed: out of sequence response")
		return
	}
	result := AppendResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	}
	value = result.GetSuccess()
	return
}

// Atomically checks if a row/family/qualifier value matches the expected
// value. If it does, it adds the corresponding mutation operation for put.
//
// @return true if the new put was executed, false otherwise
//
// Parameters:
//  - TableName: name of table
//  - Row: row key
//  - Column: column name
//  - Value: the expected value for the column parameter, if not
// provided the check is for the non-existence of the
// column in question
//  - Mput: mutation for the put
//  - Attributes: Mutation attributes
func (p *HbaseClient) CheckAndPut(tableName Text, row Text, column Text, value Text, mput *Mutation, attributes map[string]Text) (r bool, err error) {
	if err = p.sendCheckAndPut(tableName, row, column, value, mput, attributes); err != nil {
		return
	}
	return p.recvCheckAndPut()
}

func (p *HbaseClient) sendCheckAndPut(tableName Text, row Text, column Text, value Text, mput *Mutation, attributes map[string]Text) (err error) {
	oprot := p.OutputProtocol
	if oprot == nil {
		oprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.OutputProtocol = oprot
	}
	p.SeqId++
	if err = oprot.WriteMessageBegin("checkAndPut", thrift.CALL, p.SeqId); err != nil {
		return
	}
	args := CheckAndPutArgs{
		TableName:  tableName,
		Row:        row,
		Column:     column,
		Value:      value,
		Mput:       mput,
		Attributes: attributes,
	}
	if err = args.Write(oprot); err != nil {
		return
	}
	if err = oprot.WriteMessageEnd(); err != nil {
		return
	}
	return oprot.Flush(context.Background())
}

func (p *HbaseClient) recvCheckAndPut() (value bool, err error) {
	iprot := p.InputProtocol
	if iprot == nil {
		iprot = p.ProtocolFactory.GetProtocol(p.Transport)
		p.InputProtocol = iprot
	}
	_, mTypeId, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return
	}
	if mTypeId == thrift.EXCEPTION {
		error95 := thrift.NewTApplicationException(thrift.UNKNOWN_APPLICATION_EXCEPTION, "Unknown Exception")
		if err = error95.Read(iprot); err == nil {
			err = iprot.ReadMessageEnd()
		}
		return
	}
	if p.SeqId != seqId {
		err = thrift.NewTApplicationException(thrift.BAD_SEQUENCE_ID, "checkAndPut failed: out of sequence response")
		return
	}
	result := CheckAndPutResult{}
	if err = result.Read(iprot); err != nil {
		return
	}
	if err = iprot.ReadMessageEnd(); err != nil {
		return
	}
	if result.Io != nil {
		err = result.Io
		return
	} else if result.Ia != nil {
		err = result.Ia
		return
	}
	value = result.GetSuccess()
	return
}

type HbaseProcessor struct {
	processorMap map[string]thrift.TProcessorFunction
	handler      Hbase
}

func (p *HbaseProcessor) AddToProcessorMap(key string, processor thrift.TProcessorFunction) {
	p.processorMap[key] = processor
}

func (p *HbaseProcessor) GetProcessorFunction(key string) (processor thrift.TProcessorFunction, ok bool) {
	processor, ok = p.processorMap[key]
	return processor, ok
}

func (p *HbaseProcessor) ProcessorMap() map[string]thrift.TProcessorFunction {
	return p.processorMap
}

func NewHbaseProcessor(handler Hbase) *HbaseProcessor {

	self91 := &HbaseProcessor{handler: handler, processorMap: make(map[string]thrift.TProcessorFunction)}
	self91.processorMap["enableTable"] = &hbaseProcessorEnableTable{handler: handler}
	self91.processorMap["disableTable"] = &hbaseProcessorDisableTable{handler: handler}
	self91.processorMap["isTableEnabled"] = &hbaseProcessorIsTableEnabled{handler: handler}
	self91.processorMap["compact"] = &hbaseProcessorCompact{handler: handler}
	self91.processorMap["majorCompact"] = &hbaseProcessorMajorCompact{handler: handler}
	self91.processorMap["getTableNames"] = &hbaseProcessorGetTableNames{handler: handler}
	self91.processorMap["getColumnDescriptors"] = &hbaseProcessorGetColumnDescriptors{handler: handler}
	self91.processorMap["getTableRegions"] = &hbaseProcessorGetTableRegions{handler: handler}
	self91.processorMap["createTable"] = &hbaseProcessorCreateTable{handler: handler}
	self91.processorMap["deleteTable"] = &hbaseProcessorDeleteTable{handler: handler}
	self91.processorMap["get"] = &hbaseProcessorGet{handler: handler}
	self91.processorMap["getVer"] = &hbaseProcessorGetVer{handler: handler}
	self91.processorMap["getVerTs"] = &hbaseProcessorGetVerTs{handler: handler}
	self91.processorMap["getRow"] = &hbaseProcessorGetRow{handler: handler}
	self91.processorMap["getRowWithColumns"] = &hbaseProcessorGetRowWithColumns{handler: handler}
	self91.processorMap["getRowTs"] = &hbaseProcessorGetRowTs{handler: handler}
	self91.processorMap["getRowWithColumnsTs"] = &hbaseProcessorGetRowWithColumnsTs{handler: handler}
	self91.processorMap["getRows"] = &hbaseProcessorGetRows{handler: handler}
	self91.processorMap["getRowsWithColumns"] = &hbaseProcessorGetRowsWithColumns{handler: handler}
	self91.processorMap["getRowsTs"] = &hbaseProcessorGetRowsTs{handler: handler}
	self91.processorMap["getRowsWithColumnsTs"] = &hbaseProcessorGetRowsWithColumnsTs{handler: handler}
	self91.processorMap["mutateRow"] = &hbaseProcessorMutateRow{handler: handler}
	self91.processorMap["mutateRowTs"] = &hbaseProcessorMutateRowTs{handler: handler}
	self91.processorMap["mutateRows"] = &hbaseProcessorMutateRows{handler: handler}
	self91.processorMap["mutateRowsTs"] = &hbaseProcessorMutateRowsTs{handler: handler}
	self91.processorMap["atomicIncrement"] = &hbaseProcessorAtomicIncrement{handler: handler}
	self91.processorMap["deleteAll"] = &hbaseProcessorDeleteAll{handler: handler}
	self91.processorMap["deleteAllTs"] = &hbaseProcessorDeleteAllTs{handler: handler}
	self91.processorMap["deleteAllRow"] = &hbaseProcessorDeleteAllRow{handler: handler}
	self91.processorMap["increment"] = &hbaseProcessorIncrement{handler: handler}
	self91.processorMap["incrementRows"] = &hbaseProcessorIncrementRows{handler: handler}
	self91.processorMap["deleteAllRowTs"] = &hbaseProcessorDeleteAllRowTs{handler: handler}
	self91.processorMap["scannerOpenWithScan"] = &hbaseProcessorScannerOpenWithScan{handler: handler}
	self91.processorMap["scannerOpen"] = &hbaseProcessorScannerOpen{handler: handler}
	self91.processorMap["scannerOpenWithStop"] = &hbaseProcessorScannerOpenWithStop{handler: handler}
	self91.processorMap["scannerOpenWithPrefix"] = &hbaseProcessorScannerOpenWithPrefix{handler: handler}
	self91.processorMap["scannerOpenTs"] = &hbaseProcessorScannerOpenTs{handler: handler}
	self91.processorMap["scannerOpenWithStopTs"] = &hbaseProcessorScannerOpenWithStopTs{handler: handler}
	self91.processorMap["scannerGet"] = &hbaseProcessorScannerGet{handler: handler}
	self91.processorMap["scannerGetList"] = &hbaseProcessorScannerGetList{handler: handler}
	self91.processorMap["scannerClose"] = &hbaseProcessorScannerClose{handler: handler}
	self91.processorMap["getRowOrBefore"] = &hbaseProcessorGetRowOrBefore{handler: handler}
	self91.processorMap["getRegionInfo"] = &hbaseProcessorGetRegionInfo{handler: handler}
	self91.processorMap["append"] = &hbaseProcessorAppend{handler: handler}
	self91.processorMap["checkAndPut"] = &hbaseProcessorCheckAndPut{handler: handler}
	return self91
}

func (p *HbaseProcessor) Process(ctx context.Context, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	name, _, seqId, err := iprot.ReadMessageBegin()
	if err != nil {
		return false, err
	}
	if processor, ok := p.GetProcessorFunction(name); ok {
		return processor.Process(ctx, seqId, iprot, oprot)
	}
	iprot.Skip(thrift.STRUCT)
	iprot.ReadMessageEnd()
	x92 := thrift.NewTApplicationException(thrift.UNKNOWN_METHOD, "Unknown function "+name)
	oprot.WriteMessageBegin(name, thrift.EXCEPTION, seqId)
	x92.Write(oprot)
	oprot.WriteMessageEnd()
	oprot.Flush(ctx)
	return false, x92

}

type hbaseProcessorEnableTable struct {
	handler Hbase
}

func (p *hbaseProcessorEnableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := EnableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := EnableTableResult{}
	var err2 error
	if err2 = p.handler.EnableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing enableTable: "+err2.Error())
			oprot.WriteMessageBegin("enableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("enableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDisableTable struct {
	handler Hbase
}

func (p *hbaseProcessorDisableTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DisableTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DisableTableResult{}
	var err2 error
	if err2 = p.handler.DisableTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing disableTable: "+err2.Error())
			oprot.WriteMessageBegin("disableTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("disableTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIsTableEnabled struct {
	handler Hbase
}

func (p *hbaseProcessorIsTableEnabled) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IsTableEnabledArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IsTableEnabledResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.IsTableEnabled(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing isTableEnabled: "+err2.Error())
			oprot.WriteMessageBegin("isTableEnabled", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("isTableEnabled", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorCompact) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CompactArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CompactResult{}
	var err2 error
	if err2 = p.handler.Compact(args.TableNameOrRegionName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing compact: "+err2.Error())
			oprot.WriteMessageBegin("compact", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("compact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMajorCompact struct {
	handler Hbase
}

func (p *hbaseProcessorMajorCompact) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MajorCompactArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MajorCompactResult{}
	var err2 error
	if err2 = p.handler.MajorCompact(args.TableNameOrRegionName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing majorCompact: "+err2.Error())
			oprot.WriteMessageBegin("majorCompact", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("majorCompact", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableNames struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableNames) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableNamesArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableNamesResult{}
	var retval [][]byte
	var err2 error
	if retval, err2 = p.handler.GetTableNames(); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableNames: "+err2.Error())
			oprot.WriteMessageBegin("getTableNames", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableNames", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetColumnDescriptors struct {
	handler Hbase
}

func (p *hbaseProcessorGetColumnDescriptors) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetColumnDescriptorsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetColumnDescriptorsResult{}
	var retval map[string]*ColumnDescriptor
	var err2 error
	if retval, err2 = p.handler.GetColumnDescriptors(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getColumnDescriptors: "+err2.Error())
			oprot.WriteMessageBegin("getColumnDescriptors", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getColumnDescriptors", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetTableRegions struct {
	handler Hbase
}

func (p *hbaseProcessorGetTableRegions) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetTableRegionsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetTableRegionsResult{}
	var retval []*TRegionInfo
	var err2 error
	if retval, err2 = p.handler.GetTableRegions(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getTableRegions: "+err2.Error())
			oprot.WriteMessageBegin("getTableRegions", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getTableRegions", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCreateTable struct {
	handler Hbase
}

func (p *hbaseProcessorCreateTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CreateTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CreateTableResult{}
	var err2 error
	if err2 = p.handler.CreateTable(args.TableName, args.ColumnFamilies); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		case *AlreadyExists:
			result.Exist = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing createTable: "+err2.Error())
			oprot.WriteMessageBegin("createTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("createTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteTable struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteTable) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteTableArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteTableResult{}
	var err2 error
	if err2 = p.handler.DeleteTable(args.TableName); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteTable: "+err2.Error())
			oprot.WriteMessageBegin("deleteTable", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteTable", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGet struct {
	handler Hbase
}

func (p *hbaseProcessorGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetResult{}
	var retval []*TCell
	var err2 error
	if retval, err2 = p.handler.Get(args.TableName, args.Row, args.Column, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing get: "+err2.Error())
			oprot.WriteMessageBegin("get", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("get", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVer struct {
	handler Hbase
}

func (p *hbaseProcessorGetVer) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetVerArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetVerResult{}
	var retval []*TCell
	var err2 error
	if retval, err2 = p.handler.GetVer(args.TableName, args.Row, args.Column, args.NumVersions, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVer: "+err2.Error())
			oprot.WriteMessageBegin("getVer", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getVer", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetVerTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetVerTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetVerTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetVerTsResult{}
	var retval []*TCell
	var err2 error
	if retval, err2 = p.handler.GetVerTs(args.TableName, args.Row, args.Column, args.Timestamp, args.NumVersions, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getVerTs: "+err2.Error())
			oprot.WriteMessageBegin("getVerTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getVerTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRow struct {
	handler Hbase
}

func (p *hbaseProcessorGetRow) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRow(args.TableName, args.Row, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRow: "+err2.Error())
			oprot.WriteMessageBegin("getRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowWithColumnsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowWithColumnsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowWithColumns(args.TableName, args.Row, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumns: "+err2.Error())
			oprot.WriteMessageBegin("getRowWithColumns", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowTsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowWithColumnsTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowWithColumnsTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowWithColumnsTsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowWithColumnsTs(args.TableName, args.Row, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowWithColumnsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRows struct {
	handler Hbase
}

func (p *hbaseProcessorGetRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRows(args.TableName, args.Rows, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRows: "+err2.Error())
			oprot.WriteMessageBegin("getRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumns struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumns) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowsWithColumnsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowsWithColumnsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowsWithColumns(args.TableName, args.Rows, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumns: "+err2.Error())
			oprot.WriteMessageBegin("getRowsWithColumns", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowsWithColumns", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowsTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowsTsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowsTs(args.TableName, args.Rows, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowsWithColumnsTs struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowsWithColumnsTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowsWithColumnsTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowsWithColumnsTsResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.GetRowsWithColumnsTs(args.TableName, args.Rows, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowsWithColumnsTs: "+err2.Error())
			oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowsWithColumnsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRow struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRow) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowResult{}
	var err2 error
	if err2 = p.handler.MutateRow(args.TableName, args.Row, args.Mutations, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRow: "+err2.Error())
			oprot.WriteMessageBegin("mutateRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowTsResult{}
	var err2 error
	if err2 = p.handler.MutateRowTs(args.TableName, args.Row, args.Mutations, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowTs: "+err2.Error())
			oprot.WriteMessageBegin("mutateRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRows struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowsResult{}
	var err2 error
	if err2 = p.handler.MutateRows(args.TableName, args.RowBatches, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRows: "+err2.Error())
			oprot.WriteMessageBegin("mutateRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorMutateRowsTs struct {
	handler Hbase
}

func (p *hbaseProcessorMutateRowsTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := MutateRowsTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := MutateRowsTsResult{}
	var err2 error
	if err2 = p.handler.MutateRowsTs(args.TableName, args.RowBatches, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing mutateRowsTs: "+err2.Error())
			oprot.WriteMessageBegin("mutateRowsTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("mutateRowsTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorAtomicIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorAtomicIncrement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AtomicIncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AtomicIncrementResult{}
	var retval int64
	var err2 error
	if retval, err2 = p.handler.AtomicIncrement(args.TableName, args.Row, args.Column, args.Value); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing atomicIncrement: "+err2.Error())
			oprot.WriteMessageBegin("atomicIncrement", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("atomicIncrement", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAll struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAll) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteAllArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteAllResult{}
	var err2 error
	if err2 = p.handler.DeleteAll(args.TableName, args.Row, args.Column, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAll: "+err2.Error())
			oprot.WriteMessageBegin("deleteAll", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAll", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteAllTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteAllTsResult{}
	var err2 error
	if err2 = p.handler.DeleteAllTs(args.TableName, args.Row, args.Column, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllTs: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRow struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRow) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteAllRowArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteAllRowResult{}
	var err2 error
	if err2 = p.handler.DeleteAllRow(args.TableName, args.Row, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRow: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllRow", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllRow", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrement struct {
	handler Hbase
}

func (p *hbaseProcessorIncrement) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IncrementArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IncrementResult{}
	var err2 error
	if err2 = p.handler.Increment(args.Increment); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing increment: "+err2.Error())
			oprot.WriteMessageBegin("increment", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("increment", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorIncrementRows struct {
	handler Hbase
}

func (p *hbaseProcessorIncrementRows) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := IncrementRowsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := IncrementRowsResult{}
	var err2 error
	if err2 = p.handler.IncrementRows(args.Increments); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing incrementRows: "+err2.Error())
			oprot.WriteMessageBegin("incrementRows", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("incrementRows", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorDeleteAllRowTs struct {
	handler Hbase
}

func (p *hbaseProcessorDeleteAllRowTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := DeleteAllRowTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := DeleteAllRowTsResult{}
	var err2 error
	if err2 = p.handler.DeleteAllRowTs(args.TableName, args.Row, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing deleteAllRowTs: "+err2.Error())
			oprot.WriteMessageBegin("deleteAllRowTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("deleteAllRowTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithScan struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithScan) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenWithScanArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenWithScanResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpenWithScan(args.TableName, args.Scan, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithScan: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithScan", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithScan", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpen struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpen) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpen(args.TableName, args.StartRow, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpen: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpen", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpen", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStop struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStop) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenWithStopArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenWithStopResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpenWithStop(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStop: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithStop", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithStop", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithPrefix struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithPrefix) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenWithPrefixArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenWithPrefixResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpenWithPrefix(args.TableName, args.StartAndPrefix, args.Columns, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithPrefix: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithPrefix", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenTsResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpenTs(args.TableName, args.StartRow, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenTs: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerOpenWithStopTs struct {
	handler Hbase
}

func (p *hbaseProcessorScannerOpenWithStopTs) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerOpenWithStopTsArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerOpenWithStopTsResult{}
	var retval ScannerID
	var err2 error
	if retval, err2 = p.handler.ScannerOpenWithStopTs(args.TableName, args.StartRow, args.StopRow, args.Columns, args.Timestamp, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerOpenWithStopTs: "+err2.Error())
			oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("scannerOpenWithStopTs", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGet struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGet) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerGetArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerGetResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.ScannerGet(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGet: "+err2.Error())
			oprot.WriteMessageBegin("scannerGet", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("scannerGet", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerGetList struct {
	handler Hbase
}

func (p *hbaseProcessorScannerGetList) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerGetListArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerGetListResult{}
	var retval []*TRowResult_
	var err2 error
	if retval, err2 = p.handler.ScannerGetList(args.Id, args.NbRows); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerGetList: "+err2.Error())
			oprot.WriteMessageBegin("scannerGetList", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("scannerGetList", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorScannerClose struct {
	handler Hbase
}

func (p *hbaseProcessorScannerClose) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := ScannerCloseArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := ScannerCloseResult{}
	var err2 error
	if err2 = p.handler.ScannerClose(args.Id); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing scannerClose: "+err2.Error())
			oprot.WriteMessageBegin("scannerClose", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	}
	if err2 = oprot.WriteMessageBegin("scannerClose", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRowOrBefore struct {
	handler Hbase
}

func (p *hbaseProcessorGetRowOrBefore) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRowOrBeforeArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRowOrBeforeResult{}
	var retval []*TCell
	var err2 error
	if retval, err2 = p.handler.GetRowOrBefore(args.TableName, args.Row, args.Family); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRowOrBefore: "+err2.Error())
			oprot.WriteMessageBegin("getRowOrBefore", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRowOrBefore", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorGetRegionInfo struct {
	handler Hbase
}

func (p *hbaseProcessorGetRegionInfo) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := GetRegionInfoArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := GetRegionInfoResult{}
	var retval *TRegionInfo
	var err2 error
	if retval, err2 = p.handler.GetRegionInfo(args.Row); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing getRegionInfo: "+err2.Error())
			oprot.WriteMessageBegin("getRegionInfo", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("getRegionInfo", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorAppend struct {
	handler Hbase
}

func (p *hbaseProcessorAppend) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := AppendArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := AppendResult{}
	var retval []*TCell
	var err2 error
	if retval, err2 = p.handler.Append(args.Append); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing append: "+err2.Error())
			oprot.WriteMessageBegin("append", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = retval
	}
	if err2 = oprot.WriteMessageBegin("append", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

type hbaseProcessorCheckAndPut struct {
	handler Hbase
}

func (p *hbaseProcessorCheckAndPut) Process(ctx context.Context, seqId int32, iprot, oprot thrift.TProtocol) (success bool, err thrift.TException) {
	args := CheckAndPutArgs{}
	if err = args.Read(iprot); err != nil {
		iprot.ReadMessageEnd()
		x := thrift.NewTApplicationException(thrift.PROTOCOL_ERROR, err.Error())
		oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
		x.Write(oprot)
		oprot.WriteMessageEnd()
		oprot.Flush(ctx)
		return false, err
	}

	iprot.ReadMessageEnd()
	result := CheckAndPutResult{}
	var retval bool
	var err2 error
	if retval, err2 = p.handler.CheckAndPut(args.TableName, args.Row, args.Column, args.Value, args.Mput, args.Attributes); err2 != nil {
		switch v := err2.(type) {
		case *IOError:
			result.Io = v
		case *IllegalArgument:
			result.Ia = v
		default:
			x := thrift.NewTApplicationException(thrift.INTERNAL_ERROR, "Internal error processing checkAndPut: "+err2.Error())
			oprot.WriteMessageBegin("checkAndPut", thrift.EXCEPTION, seqId)
			x.Write(oprot)
			oprot.WriteMessageEnd()
			oprot.Flush(ctx)
			return true, err2
		}
	} else {
		result.Success = &retval
	}
	if err2 = oprot.WriteMessageBegin("checkAndPut", thrift.REPLY, seqId); err2 != nil {
		err = err2
	}
	if err2 = result.Write(oprot); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.WriteMessageEnd(); err == nil && err2 != nil {
		err = err2
	}
	if err2 = oprot.Flush(ctx); err == nil && err2 != nil {
		err = err2
	}
	if err != nil {
		return
	}
	return true, err
}

// HELPER FUNCTIONS AND STRUCTURES

type EnableTableArgs struct {
	TableName Bytes `thrift:"tableName,1" json:"tableName"`
}

func NewEnableTableArgs() *EnableTableArgs {
	return &EnableTableArgs{}
}

func (p *EnableTableArgs) GetTableName() Bytes {
	return p.TableName
}
func (p *EnableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *EnableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *EnableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableArgs(%+v)", *p)
}

type EnableTableResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewEnableTableResult() *EnableTableResult {
	return &EnableTableResult{}
}

var EnableTableResult_Io_DEFAULT *IOError

func (p *EnableTableResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return EnableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *EnableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *EnableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *EnableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *EnableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("enableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *EnableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *EnableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("EnableTableResult(%+v)", *p)
}

type DisableTableArgs struct {
	TableName Bytes `thrift:"tableName,1" json:"tableName"`
}

func NewDisableTableArgs() *DisableTableArgs {
	return &DisableTableArgs{}
}

func (p *DisableTableArgs) GetTableName() Bytes {
	return p.TableName
}
func (p *DisableTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *DisableTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DisableTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableArgs(%+v)", *p)
}

type DisableTableResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDisableTableResult() *DisableTableResult {
	return &DisableTableResult{}
}

var DisableTableResult_Io_DEFAULT *IOError

func (p *DisableTableResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DisableTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DisableTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DisableTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DisableTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DisableTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("disableTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DisableTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DisableTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DisableTableResult(%+v)", *p)
}

type IsTableEnabledArgs struct {
	TableName Bytes `thrift:"tableName,1" json:"tableName"`
}

func NewIsTableEnabledArgs() *IsTableEnabledArgs {
	return &IsTableEnabledArgs{}
}

func (p *IsTableEnabledArgs) GetTableName() Bytes {
	return p.TableName
}
func (p *IsTableEnabledArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableName = temp
	}
	return nil
}

func (p *IsTableEnabledArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *IsTableEnabledArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledArgs(%+v)", *p)
}

type IsTableEnabledResult struct {
	Success *bool    `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewIsTableEnabledResult() *IsTableEnabledResult {
	return &IsTableEnabledResult{}
}

var IsTableEnabledResult_Success_DEFAULT bool

func (p *IsTableEnabledResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return IsTableEnabledResult_Success_DEFAULT
	}
	return *p.Success
}

var IsTableEnabledResult_Io_DEFAULT *IOError

func (p *IsTableEnabledResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return IsTableEnabledResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IsTableEnabledResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *IsTableEnabledResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IsTableEnabledResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *IsTableEnabledResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IsTableEnabledResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("isTableEnabled_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IsTableEnabledResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IsTableEnabledResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IsTableEnabledResult(%+v)", *p)
}

type CompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1" json:"tableNameOrRegionName"`
}

func NewCompactArgs() *CompactArgs {
	return &CompactArgs{}
}

func (p *CompactArgs) GetTableNameOrRegionName() Bytes {
	return p.TableNameOrRegionName
}
func (p *CompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableNameOrRegionName = temp
	}
	return nil
}

func (p *CompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
		return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
	}
	return err
}

func (p *CompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactArgs(%+v)", *p)
}

type CompactResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewCompactResult() *CompactResult {
	return &CompactResult{}
}

var CompactResult_Io_DEFAULT *IOError

func (p *CompactResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return CompactResult_Io_DEFAULT
	}
	return p.Io
}
func (p *CompactResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CompactResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("compact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CompactResult(%+v)", *p)
}

type MajorCompactArgs struct {
	TableNameOrRegionName Bytes `thrift:"tableNameOrRegionName,1" json:"tableNameOrRegionName"`
}

func NewMajorCompactArgs() *MajorCompactArgs {
	return &MajorCompactArgs{}
}

func (p *MajorCompactArgs) GetTableNameOrRegionName() Bytes {
	return p.TableNameOrRegionName
}
func (p *MajorCompactArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Bytes(v)
		p.TableNameOrRegionName = temp
	}
	return nil
}

func (p *MajorCompactArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableNameOrRegionName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableNameOrRegionName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableNameOrRegionName); err != nil {
		return fmt.Errorf("%T.tableNameOrRegionName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableNameOrRegionName: %s", p, err)
	}
	return err
}

func (p *MajorCompactArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactArgs(%+v)", *p)
}

type MajorCompactResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewMajorCompactResult() *MajorCompactResult {
	return &MajorCompactResult{}
}

var MajorCompactResult_Io_DEFAULT *IOError

func (p *MajorCompactResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return MajorCompactResult_Io_DEFAULT
	}
	return p.Io
}
func (p *MajorCompactResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MajorCompactResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MajorCompactResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MajorCompactResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("majorCompact_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MajorCompactResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MajorCompactResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MajorCompactResult(%+v)", *p)
}

type GetTableNamesArgs struct {
}

func NewGetTableNamesArgs() *GetTableNamesArgs {
	return &GetTableNamesArgs{}
}

func (p *GetTableNamesArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		if err := iprot.Skip(fieldTypeId); err != nil {
			return err
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesArgs(%+v)", *p)
}

type GetTableNamesResult struct {
	Success [][]byte `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewGetTableNamesResult() *GetTableNamesResult {
	return &GetTableNamesResult{}
}

var GetTableNamesResult_Success_DEFAULT [][]byte

func (p *GetTableNamesResult) GetSuccess() [][]byte {
	return p.Success
}

var GetTableNamesResult_Io_DEFAULT *IOError

func (p *GetTableNamesResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetTableNamesResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableNamesResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableNamesResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableNamesResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableNamesResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		var _elem93 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem93 = temp
		}
		p.Success = append(p.Success, _elem93)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableNamesResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableNamesResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableNames_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableNamesResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRING, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := oprot.WriteBinary(v); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableNamesResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableNamesResult(%+v)", *p)
}

type GetColumnDescriptorsArgs struct {
	TableName Text `thrift:"tableName,1" json:"tableName"`
}

func NewGetColumnDescriptorsArgs() *GetColumnDescriptorsArgs {
	return &GetColumnDescriptorsArgs{}
}

func (p *GetColumnDescriptorsArgs) GetTableName() Text {
	return p.TableName
}
func (p *GetColumnDescriptorsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetColumnDescriptorsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsArgs(%+v)", *p)
}

type GetColumnDescriptorsResult struct {
	Success map[string]*ColumnDescriptor `thrift:"success,0" json:"success"`
	Io      *IOError                     `thrift:"io,1" json:"io"`
}

func NewGetColumnDescriptorsResult() *GetColumnDescriptorsResult {
	return &GetColumnDescriptorsResult{}
}

var GetColumnDescriptorsResult_Success_DEFAULT map[string]*ColumnDescriptor

func (p *GetColumnDescriptorsResult) GetSuccess() map[string]*ColumnDescriptor {
	return p.Success
}

var GetColumnDescriptorsResult_Io_DEFAULT *IOError

func (p *GetColumnDescriptorsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetColumnDescriptorsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetColumnDescriptorsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetColumnDescriptorsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetColumnDescriptorsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) ReadField0(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]*ColumnDescriptor, size)
	p.Success = tMap
	for i := 0; i < size; i++ {
		var _key94 string
		if _key94, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		_val95 := &ColumnDescriptor{
			MaxVersions: 3,

			Compression: "NONE",

			BloomFilterType: "NONE",

			TimeToLive: 2147483647,
		}
		if err := _val95.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _val95, err)
		}
		p.Success[_key94] = _val95
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getColumnDescriptors_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetColumnDescriptorsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.MAP, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing map begin: %s", err)
		}
		for k, v := range p.Success {
			if err := oprot.WriteString(string(k)); err != nil {
				return fmt.Errorf("%T. (0) field write error: %s", p, err)
			}
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteMapEnd(); err != nil {
			return fmt.Errorf("error writing map end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetColumnDescriptorsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetColumnDescriptorsResult(%+v)", *p)
}

type GetTableRegionsArgs struct {
	TableName Text `thrift:"tableName,1" json:"tableName"`
}

func NewGetTableRegionsArgs() *GetTableRegionsArgs {
	return &GetTableRegionsArgs{}
}

func (p *GetTableRegionsArgs) GetTableName() Text {
	return p.TableName
}
func (p *GetTableRegionsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetTableRegionsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetTableRegionsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsArgs(%+v)", *p)
}

type GetTableRegionsResult struct {
	Success []*TRegionInfo `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetTableRegionsResult() *GetTableRegionsResult {
	return &GetTableRegionsResult{}
}

var GetTableRegionsResult_Success_DEFAULT []*TRegionInfo

func (p *GetTableRegionsResult) GetSuccess() []*TRegionInfo {
	return p.Success
}

var GetTableRegionsResult_Io_DEFAULT *IOError

func (p *GetTableRegionsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetTableRegionsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetTableRegionsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetTableRegionsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetTableRegionsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetTableRegionsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRegionInfo, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem96 := &TRegionInfo{}
		if err := _elem96.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem96, err)
		}
		p.Success = append(p.Success, _elem96)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetTableRegionsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetTableRegionsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getTableRegions_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetTableRegionsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetTableRegionsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetTableRegionsResult(%+v)", *p)
}

type CreateTableArgs struct {
	TableName      Text                `thrift:"tableName,1" json:"tableName"`
	ColumnFamilies []*ColumnDescriptor `thrift:"columnFamilies,2" json:"columnFamilies"`
}

func NewCreateTableArgs() *CreateTableArgs {
	return &CreateTableArgs{}
}

func (p *CreateTableArgs) GetTableName() Text {
	return p.TableName
}

func (p *CreateTableArgs) GetColumnFamilies() []*ColumnDescriptor {
	return p.ColumnFamilies
}
func (p *CreateTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *CreateTableArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*ColumnDescriptor, 0, size)
	p.ColumnFamilies = tSlice
	for i := 0; i < size; i++ {
		_elem97 := &ColumnDescriptor{
			MaxVersions: 3,

			Compression: "NONE",

			BloomFilterType: "NONE",

			TimeToLive: 2147483647,
		}
		if err := _elem97.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem97, err)
		}
		p.ColumnFamilies = append(p.ColumnFamilies, _elem97)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columnFamilies", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:columnFamilies: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.ColumnFamilies)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.ColumnFamilies {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:columnFamilies: %s", p, err)
	}
	return err
}

func (p *CreateTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableArgs(%+v)", *p)
}

type CreateTableResult struct {
	Io    *IOError         `thrift:"io,1" json:"io"`
	Ia    *IllegalArgument `thrift:"ia,2" json:"ia"`
	Exist *AlreadyExists   `thrift:"exist,3" json:"exist"`
}

func NewCreateTableResult() *CreateTableResult {
	return &CreateTableResult{}
}

var CreateTableResult_Io_DEFAULT *IOError

func (p *CreateTableResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return CreateTableResult_Io_DEFAULT
	}
	return p.Io
}

var CreateTableResult_Ia_DEFAULT *IllegalArgument

func (p *CreateTableResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return CreateTableResult_Ia_DEFAULT
	}
	return p.Ia
}

var CreateTableResult_Exist_DEFAULT *AlreadyExists

func (p *CreateTableResult) GetExist() *AlreadyExists {
	if !p.IsSetExist() {
		return CreateTableResult_Exist_DEFAULT
	}
	return p.Exist
}
func (p *CreateTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CreateTableResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *CreateTableResult) IsSetExist() bool {
	return p.Exist != nil
}

func (p *CreateTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CreateTableResult) ReadField3(iprot thrift.TProtocol) error {
	p.Exist = &AlreadyExists{}
	if err := p.Exist.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Exist, err)
	}
	return nil
}

func (p *CreateTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("createTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CreateTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) writeField3(oprot thrift.TProtocol) (err error) {
	if p.IsSetExist() {
		if err := oprot.WriteFieldBegin("exist", thrift.STRUCT, 3); err != nil {
			return fmt.Errorf("%T write field begin error 3:exist: %s", p, err)
		}
		if err := p.Exist.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Exist, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 3:exist: %s", p, err)
		}
	}
	return err
}

func (p *CreateTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CreateTableResult(%+v)", *p)
}

type DeleteTableArgs struct {
	TableName Text `thrift:"tableName,1" json:"tableName"`
}

func NewDeleteTableArgs() *DeleteTableArgs {
	return &DeleteTableArgs{}
}

func (p *DeleteTableArgs) GetTableName() Text {
	return p.TableName
}
func (p *DeleteTableArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteTableArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteTableArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableArgs(%+v)", *p)
}

type DeleteTableResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDeleteTableResult() *DeleteTableResult {
	return &DeleteTableResult{}
}

var DeleteTableResult_Io_DEFAULT *IOError

func (p *DeleteTableResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DeleteTableResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteTableResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteTableResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteTableResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteTableResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteTable_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteTableResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteTableResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteTableResult(%+v)", *p)
}

type GetArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Column     Text            `thrift:"column,3" json:"column"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewGetArgs() *GetArgs {
	return &GetArgs{}
}

func (p *GetArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetArgs) GetRow() Text {
	return p.Row
}

func (p *GetArgs) GetColumn() Text {
	return p.Column
}

func (p *GetArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key98 string
		if _key98, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val99 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val99 = temp
		}
		p.Attributes[_key98] = _val99
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *GetArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *GetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetArgs(%+v)", *p)
}

type GetResult struct {
	Success []*TCell `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewGetResult() *GetResult {
	return &GetResult{}
}

var GetResult_Success_DEFAULT []*TCell

func (p *GetResult) GetSuccess() []*TCell {
	return p.Success
}

var GetResult_Io_DEFAULT *IOError

func (p *GetResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem100 := &TCell{}
		if err := _elem100.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem100, err)
		}
		p.Success = append(p.Success, _elem100)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("get_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetResult(%+v)", *p)
}

type GetVerArgs struct {
	TableName   Text            `thrift:"tableName,1" json:"tableName"`
	Row         Text            `thrift:"row,2" json:"row"`
	Column      Text            `thrift:"column,3" json:"column"`
	NumVersions int32           `thrift:"numVersions,4" json:"numVersions"`
	Attributes  map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewGetVerArgs() *GetVerArgs {
	return &GetVerArgs{}
}

func (p *GetVerArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetVerArgs) GetRow() Text {
	return p.Row
}

func (p *GetVerArgs) GetColumn() Text {
	return p.Column
}

func (p *GetVerArgs) GetNumVersions() int32 {
	return p.NumVersions
}

func (p *GetVerArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetVerArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetVerArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key101 string
		if _key101, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val102 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val102 = temp
		}
		p.Attributes[_key101] = _val102
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetVerArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *GetVerArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerArgs(%+v)", *p)
}

type GetVerResult struct {
	Success []*TCell `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewGetVerResult() *GetVerResult {
	return &GetVerResult{}
}

var GetVerResult_Success_DEFAULT []*TCell

func (p *GetVerResult) GetSuccess() []*TCell {
	return p.Success
}

var GetVerResult_Io_DEFAULT *IOError

func (p *GetVerResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetVerResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetVerResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetVerResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetVerResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem103 := &TCell{}
		if err := _elem103.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem103, err)
		}
		p.Success = append(p.Success, _elem103)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetVerResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetVerResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVer_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerResult(%+v)", *p)
}

type GetVerTsArgs struct {
	TableName   Text            `thrift:"tableName,1" json:"tableName"`
	Row         Text            `thrift:"row,2" json:"row"`
	Column      Text            `thrift:"column,3" json:"column"`
	Timestamp   int64           `thrift:"timestamp,4" json:"timestamp"`
	NumVersions int32           `thrift:"numVersions,5" json:"numVersions"`
	Attributes  map[string]Text `thrift:"attributes,6" json:"attributes"`
}

func NewGetVerTsArgs() *GetVerTsArgs {
	return &GetVerTsArgs{}
}

func (p *GetVerTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetVerTsArgs) GetRow() Text {
	return p.Row
}

func (p *GetVerTsArgs) GetColumn() Text {
	return p.Column
}

func (p *GetVerTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *GetVerTsArgs) GetNumVersions() int32 {
	return p.NumVersions
}

func (p *GetVerTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetVerTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *GetVerTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetVerTsArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.NumVersions = v
	}
	return nil
}

func (p *GetVerTsArgs) ReadField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key104 string
		if _key104, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val105 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val105 = temp
		}
		p.Attributes[_key104] = _val105
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetVerTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("numVersions", thrift.I32, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:numVersions: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NumVersions)); err != nil {
		return fmt.Errorf("%T.numVersions (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:numVersions: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
	}
	return err
}

func (p *GetVerTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsArgs(%+v)", *p)
}

type GetVerTsResult struct {
	Success []*TCell `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewGetVerTsResult() *GetVerTsResult {
	return &GetVerTsResult{}
}

var GetVerTsResult_Success_DEFAULT []*TCell

func (p *GetVerTsResult) GetSuccess() []*TCell {
	return p.Success
}

var GetVerTsResult_Io_DEFAULT *IOError

func (p *GetVerTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetVerTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetVerTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetVerTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetVerTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetVerTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem106 := &TCell{}
		if err := _elem106.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem106, err)
		}
		p.Success = append(p.Success, _elem106)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetVerTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetVerTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getVerTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetVerTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetVerTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetVerTsResult(%+v)", *p)
}

type GetRowArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Attributes map[string]Text `thrift:"attributes,3" json:"attributes"`
}

func NewGetRowArgs() *GetRowArgs {
	return &GetRowArgs{}
}

func (p *GetRowArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowArgs) GetRow() Text {
	return p.Row
}

func (p *GetRowArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key107 string
		if _key107, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val108 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val108 = temp
		}
		p.Attributes[_key107] = _val108
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowArgs(%+v)", *p)
}

type GetRowResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowResult() *GetRowResult {
	return &GetRowResult{}
}

var GetRowResult_Success_DEFAULT []*TRowResult_

func (p *GetRowResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowResult_Io_DEFAULT *IOError

func (p *GetRowResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem109 := &TRowResult_{}
		if err := _elem109.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem109, err)
		}
		p.Success = append(p.Success, _elem109)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowResult(%+v)", *p)
}

type GetRowWithColumnsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewGetRowWithColumnsArgs() *GetRowWithColumnsArgs {
	return &GetRowWithColumnsArgs{}
}

func (p *GetRowWithColumnsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowWithColumnsArgs) GetRow() Text {
	return p.Row
}

func (p *GetRowWithColumnsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *GetRowWithColumnsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem110 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem110 = temp
		}
		p.Columns = append(p.Columns, _elem110)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key111 string
		if _key111, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val112 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val112 = temp
		}
		p.Attributes[_key111] = _val112
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsArgs(%+v)", *p)
}

type GetRowWithColumnsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowWithColumnsResult() *GetRowWithColumnsResult {
	return &GetRowWithColumnsResult{}
}

var GetRowWithColumnsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowWithColumnsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowWithColumnsResult_Io_DEFAULT *IOError

func (p *GetRowWithColumnsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowWithColumnsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowWithColumnsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowWithColumnsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem113 := &TRowResult_{}
		if err := _elem113.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem113, err)
		}
		p.Success = append(p.Success, _elem113)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsResult(%+v)", *p)
}

type GetRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Timestamp  int64           `thrift:"timestamp,3" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewGetRowTsArgs() *GetRowTsArgs {
	return &GetRowTsArgs{}
}

func (p *GetRowTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowTsArgs) GetRow() Text {
	return p.Row
}

func (p *GetRowTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *GetRowTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key114 string
		if _key114, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val115 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val115 = temp
		}
		p.Attributes[_key114] = _val115
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsArgs(%+v)", *p)
}

type GetRowTsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowTsResult() *GetRowTsResult {
	return &GetRowTsResult{}
}

var GetRowTsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowTsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowTsResult_Io_DEFAULT *IOError

func (p *GetRowTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem116 := &TRowResult_{}
		if err := _elem116.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem116, err)
		}
		p.Success = append(p.Success, _elem116)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowTsResult(%+v)", *p)
}

type GetRowWithColumnsTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Timestamp  int64           `thrift:"timestamp,4" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewGetRowWithColumnsTsArgs() *GetRowWithColumnsTsArgs {
	return &GetRowWithColumnsTsArgs{}
}

func (p *GetRowWithColumnsTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowWithColumnsTsArgs) GetRow() Text {
	return p.Row
}

func (p *GetRowWithColumnsTsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *GetRowWithColumnsTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *GetRowWithColumnsTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem117 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem117 = temp
		}
		p.Columns = append(p.Columns, _elem117)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key118 string
		if _key118, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val119 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val119 = temp
		}
		p.Attributes[_key118] = _val119
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsArgs(%+v)", *p)
}

type GetRowWithColumnsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowWithColumnsTsResult() *GetRowWithColumnsTsResult {
	return &GetRowWithColumnsTsResult{}
}

var GetRowWithColumnsTsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowWithColumnsTsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowWithColumnsTsResult_Io_DEFAULT *IOError

func (p *GetRowWithColumnsTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowWithColumnsTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowWithColumnsTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowWithColumnsTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem120 := &TRowResult_{}
		if err := _elem120.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem120, err)
		}
		p.Success = append(p.Success, _elem120)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowWithColumnsTsResult(%+v)", *p)
}

type GetRowsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Rows       [][]byte        `thrift:"rows,2" json:"rows"`
	Attributes map[string]Text `thrift:"attributes,3" json:"attributes"`
}

func NewGetRowsArgs() *GetRowsArgs {
	return &GetRowsArgs{}
}

func (p *GetRowsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowsArgs) GetRows() [][]byte {
	return p.Rows
}

func (p *GetRowsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem121 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem121 = temp
		}
		p.Rows = append(p.Rows, _elem121)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key122 string
		if _key122, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val123 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val123 = temp
		}
		p.Attributes[_key122] = _val123
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Rows {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
	}
	return err
}

func (p *GetRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsArgs(%+v)", *p)
}

type GetRowsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowsResult() *GetRowsResult {
	return &GetRowsResult{}
}

var GetRowsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowsResult_Io_DEFAULT *IOError

func (p *GetRowsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem124 := &TRowResult_{}
		if err := _elem124.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem124, err)
		}
		p.Success = append(p.Success, _elem124)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsResult(%+v)", *p)
}

type GetRowsWithColumnsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Rows       [][]byte        `thrift:"rows,2" json:"rows"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewGetRowsWithColumnsArgs() *GetRowsWithColumnsArgs {
	return &GetRowsWithColumnsArgs{}
}

func (p *GetRowsWithColumnsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowsWithColumnsArgs) GetRows() [][]byte {
	return p.Rows
}

func (p *GetRowsWithColumnsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *GetRowsWithColumnsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowsWithColumnsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem125 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem125 = temp
		}
		p.Rows = append(p.Rows, _elem125)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem126 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem126 = temp
		}
		p.Columns = append(p.Columns, _elem126)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key127 string
		if _key127, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val128 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val128 = temp
		}
		p.Attributes[_key127] = _val128
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Rows {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsArgs(%+v)", *p)
}

type GetRowsWithColumnsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowsWithColumnsResult() *GetRowsWithColumnsResult {
	return &GetRowsWithColumnsResult{}
}

var GetRowsWithColumnsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowsWithColumnsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowsWithColumnsResult_Io_DEFAULT *IOError

func (p *GetRowsWithColumnsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowsWithColumnsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowsWithColumnsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowsWithColumnsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowsWithColumnsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem129 := &TRowResult_{}
		if err := _elem129.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem129, err)
		}
		p.Success = append(p.Success, _elem129)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumns_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsResult(%+v)", *p)
}

type GetRowsTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Rows       [][]byte        `thrift:"rows,2" json:"rows"`
	Timestamp  int64           `thrift:"timestamp,3" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewGetRowsTsArgs() *GetRowsTsArgs {
	return &GetRowsTsArgs{}
}

func (p *GetRowsTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowsTsArgs) GetRows() [][]byte {
	return p.Rows
}

func (p *GetRowsTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *GetRowsTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem130 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem130 = temp
		}
		p.Rows = append(p.Rows, _elem130)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key131 string
		if _key131, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val132 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val132 = temp
		}
		p.Attributes[_key131] = _val132
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Rows {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsArgs(%+v)", *p)
}

type GetRowsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowsTsResult() *GetRowsTsResult {
	return &GetRowsTsResult{}
}

var GetRowsTsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowsTsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowsTsResult_Io_DEFAULT *IOError

func (p *GetRowsTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowsTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowsTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowsTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem133 := &TRowResult_{}
		if err := _elem133.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem133, err)
		}
		p.Success = append(p.Success, _elem133)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsTsResult(%+v)", *p)
}

type GetRowsWithColumnsTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Rows       [][]byte        `thrift:"rows,2" json:"rows"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Timestamp  int64           `thrift:"timestamp,4" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewGetRowsWithColumnsTsArgs() *GetRowsWithColumnsTsArgs {
	return &GetRowsWithColumnsTsArgs{}
}

func (p *GetRowsWithColumnsTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowsWithColumnsTsArgs) GetRows() [][]byte {
	return p.Rows
}

func (p *GetRowsWithColumnsTsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *GetRowsWithColumnsTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *GetRowsWithColumnsTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *GetRowsWithColumnsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Rows = tSlice
	for i := 0; i < size; i++ {
		var _elem134 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem134 = temp
		}
		p.Rows = append(p.Rows, _elem134)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem135 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem135 = temp
		}
		p.Columns = append(p.Columns, _elem135)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key136 string
		if _key136, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val137 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val137 = temp
		}
		p.Attributes[_key136] = _val137
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rows", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rows: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Rows)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Rows {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rows: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *GetRowsWithColumnsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsArgs(%+v)", *p)
}

type GetRowsWithColumnsTsResult struct {
	Success []*TRowResult_ `thrift:"success,0" json:"success"`
	Io      *IOError       `thrift:"io,1" json:"io"`
}

func NewGetRowsWithColumnsTsResult() *GetRowsWithColumnsTsResult {
	return &GetRowsWithColumnsTsResult{}
}

var GetRowsWithColumnsTsResult_Success_DEFAULT []*TRowResult_

func (p *GetRowsWithColumnsTsResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var GetRowsWithColumnsTsResult_Io_DEFAULT *IOError

func (p *GetRowsWithColumnsTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowsWithColumnsTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowsWithColumnsTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowsWithColumnsTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowsWithColumnsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem138 := &TRowResult_{}
		if err := _elem138.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem138, err)
		}
		p.Success = append(p.Success, _elem138)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowsWithColumnsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowsWithColumnsTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowsWithColumnsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowsWithColumnsTsResult(%+v)", *p)
}

type MutateRowArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Mutations  []*Mutation     `thrift:"mutations,3" json:"mutations"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewMutateRowArgs() *MutateRowArgs {
	return &MutateRowArgs{}
}

func (p *MutateRowArgs) GetTableName() Text {
	return p.TableName
}

func (p *MutateRowArgs) GetRow() Text {
	return p.Row
}

func (p *MutateRowArgs) GetMutations() []*Mutation {
	return p.Mutations
}

func (p *MutateRowArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *MutateRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *MutateRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Mutation, 0, size)
	p.Mutations = tSlice
	for i := 0; i < size; i++ {
		_elem139 := &Mutation{
			WriteToWAL: true,
		}
		if err := _elem139.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem139, err)
		}
		p.Mutations = append(p.Mutations, _elem139)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key140 string
		if _key140, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val141 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val141 = temp
		}
		p.Attributes[_key140] = _val141
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Mutations {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *MutateRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowArgs(%+v)", *p)
}

type MutateRowResult struct {
	Io *IOError         `thrift:"io,1" json:"io"`
	Ia *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewMutateRowResult() *MutateRowResult {
	return &MutateRowResult{}
}

var MutateRowResult_Io_DEFAULT *IOError

func (p *MutateRowResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return MutateRowResult_Io_DEFAULT
	}
	return p.Io
}

var MutateRowResult_Ia_DEFAULT *IllegalArgument

func (p *MutateRowResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return MutateRowResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *MutateRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *MutateRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowResult(%+v)", *p)
}

type MutateRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Mutations  []*Mutation     `thrift:"mutations,3" json:"mutations"`
	Timestamp  int64           `thrift:"timestamp,4" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewMutateRowTsArgs() *MutateRowTsArgs {
	return &MutateRowTsArgs{}
}

func (p *MutateRowTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *MutateRowTsArgs) GetRow() Text {
	return p.Row
}

func (p *MutateRowTsArgs) GetMutations() []*Mutation {
	return p.Mutations
}

func (p *MutateRowTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *MutateRowTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *MutateRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*Mutation, 0, size)
	p.Mutations = tSlice
	for i := 0; i < size; i++ {
		_elem142 := &Mutation{
			WriteToWAL: true,
		}
		if err := _elem142.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem142, err)
		}
		p.Mutations = append(p.Mutations, _elem142)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key143 string
		if _key143, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val144 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val144 = temp
		}
		p.Attributes[_key143] = _val144
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mutations", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:mutations: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Mutations)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Mutations {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:mutations: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *MutateRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsArgs(%+v)", *p)
}

type MutateRowTsResult struct {
	Io *IOError         `thrift:"io,1" json:"io"`
	Ia *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewMutateRowTsResult() *MutateRowTsResult {
	return &MutateRowTsResult{}
}

var MutateRowTsResult_Io_DEFAULT *IOError

func (p *MutateRowTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return MutateRowTsResult_Io_DEFAULT
	}
	return p.Io
}

var MutateRowTsResult_Ia_DEFAULT *IllegalArgument

func (p *MutateRowTsResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return MutateRowTsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *MutateRowTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowTsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *MutateRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowTsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowTsResult(%+v)", *p)
}

type MutateRowsArgs struct {
	TableName  Text             `thrift:"tableName,1" json:"tableName"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2" json:"rowBatches"`
	Attributes map[string]Text  `thrift:"attributes,3" json:"attributes"`
}

func NewMutateRowsArgs() *MutateRowsArgs {
	return &MutateRowsArgs{}
}

func (p *MutateRowsArgs) GetTableName() Text {
	return p.TableName
}

func (p *MutateRowsArgs) GetRowBatches() []*BatchMutation {
	return p.RowBatches
}

func (p *MutateRowsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *MutateRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*BatchMutation, 0, size)
	p.RowBatches = tSlice
	for i := 0; i < size; i++ {
		_elem145 := &BatchMutation{}
		if err := _elem145.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem145, err)
		}
		p.RowBatches = append(p.RowBatches, _elem145)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key146 string
		if _key146, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val147 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val147 = temp
		}
		p.Attributes[_key146] = _val147
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *MutateRowsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.RowBatches {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
	}
	return err
}

func (p *MutateRowsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
	}
	return err
}

func (p *MutateRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsArgs(%+v)", *p)
}

type MutateRowsResult struct {
	Io *IOError         `thrift:"io,1" json:"io"`
	Ia *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewMutateRowsResult() *MutateRowsResult {
	return &MutateRowsResult{}
}

var MutateRowsResult_Io_DEFAULT *IOError

func (p *MutateRowsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return MutateRowsResult_Io_DEFAULT
	}
	return p.Io
}

var MutateRowsResult_Ia_DEFAULT *IllegalArgument

func (p *MutateRowsResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return MutateRowsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *MutateRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *MutateRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsResult(%+v)", *p)
}

type MutateRowsTsArgs struct {
	TableName  Text             `thrift:"tableName,1" json:"tableName"`
	RowBatches []*BatchMutation `thrift:"rowBatches,2" json:"rowBatches"`
	Timestamp  int64            `thrift:"timestamp,3" json:"timestamp"`
	Attributes map[string]Text  `thrift:"attributes,4" json:"attributes"`
}

func NewMutateRowsTsArgs() *MutateRowsTsArgs {
	return &MutateRowsTsArgs{}
}

func (p *MutateRowsTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *MutateRowsTsArgs) GetRowBatches() []*BatchMutation {
	return p.RowBatches
}

func (p *MutateRowsTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *MutateRowsTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *MutateRowsTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField2(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*BatchMutation, 0, size)
	p.RowBatches = tSlice
	for i := 0; i < size; i++ {
		_elem148 := &BatchMutation{}
		if err := _elem148.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem148, err)
		}
		p.RowBatches = append(p.RowBatches, _elem148)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *MutateRowsTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key149 string
		if _key149, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val150 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val150 = temp
		}
		p.Attributes[_key149] = _val150
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("rowBatches", thrift.LIST, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:rowBatches: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.RowBatches)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.RowBatches {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:rowBatches: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *MutateRowsTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsArgs(%+v)", *p)
}

type MutateRowsTsResult struct {
	Io *IOError         `thrift:"io,1" json:"io"`
	Ia *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewMutateRowsTsResult() *MutateRowsTsResult {
	return &MutateRowsTsResult{}
}

var MutateRowsTsResult_Io_DEFAULT *IOError

func (p *MutateRowsTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return MutateRowsTsResult_Io_DEFAULT
	}
	return p.Io
}

var MutateRowsTsResult_Ia_DEFAULT *IllegalArgument

func (p *MutateRowsTsResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return MutateRowsTsResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *MutateRowsTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *MutateRowsTsResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *MutateRowsTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *MutateRowsTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *MutateRowsTsResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *MutateRowsTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("mutateRowsTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *MutateRowsTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *MutateRowsTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("MutateRowsTsResult(%+v)", *p)
}

type AtomicIncrementArgs struct {
	TableName Text  `thrift:"tableName,1" json:"tableName"`
	Row       Text  `thrift:"row,2" json:"row"`
	Column    Text  `thrift:"column,3" json:"column"`
	Value     int64 `thrift:"value,4" json:"value"`
}

func NewAtomicIncrementArgs() *AtomicIncrementArgs {
	return &AtomicIncrementArgs{}
}

func (p *AtomicIncrementArgs) GetTableName() Text {
	return p.TableName
}

func (p *AtomicIncrementArgs) GetRow() Text {
	return p.Row
}

func (p *AtomicIncrementArgs) GetColumn() Text {
	return p.Column
}

func (p *AtomicIncrementArgs) GetValue() int64 {
	return p.Value
}
func (p *AtomicIncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *AtomicIncrementArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Value = v
	}
	return nil
}

func (p *AtomicIncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:value: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Value)); err != nil {
		return fmt.Errorf("%T.value (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:value: %s", p, err)
	}
	return err
}

func (p *AtomicIncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementArgs(%+v)", *p)
}

type AtomicIncrementResult struct {
	Success *int64           `thrift:"success,0" json:"success"`
	Io      *IOError         `thrift:"io,1" json:"io"`
	Ia      *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewAtomicIncrementResult() *AtomicIncrementResult {
	return &AtomicIncrementResult{}
}

var AtomicIncrementResult_Success_DEFAULT int64

func (p *AtomicIncrementResult) GetSuccess() int64 {
	if !p.IsSetSuccess() {
		return AtomicIncrementResult_Success_DEFAULT
	}
	return *p.Success
}

var AtomicIncrementResult_Io_DEFAULT *IOError

func (p *AtomicIncrementResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return AtomicIncrementResult_Io_DEFAULT
	}
	return p.Io
}

var AtomicIncrementResult_Ia_DEFAULT *IllegalArgument

func (p *AtomicIncrementResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return AtomicIncrementResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *AtomicIncrementResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AtomicIncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *AtomicIncrementResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *AtomicIncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AtomicIncrementResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *AtomicIncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("atomicIncrement_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AtomicIncrementResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I64, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI64(int64(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *AtomicIncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AtomicIncrementResult(%+v)", *p)
}

type DeleteAllArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Column     Text            `thrift:"column,3" json:"column"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewDeleteAllArgs() *DeleteAllArgs {
	return &DeleteAllArgs{}
}

func (p *DeleteAllArgs) GetTableName() Text {
	return p.TableName
}

func (p *DeleteAllArgs) GetRow() Text {
	return p.Row
}

func (p *DeleteAllArgs) GetColumn() Text {
	return p.Column
}

func (p *DeleteAllArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *DeleteAllArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *DeleteAllArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key151 string
		if _key151, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val152 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val152 = temp
		}
		p.Attributes[_key151] = _val152
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteAllArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *DeleteAllArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *DeleteAllArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *DeleteAllArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllArgs(%+v)", *p)
}

type DeleteAllResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDeleteAllResult() *DeleteAllResult {
	return &DeleteAllResult{}
}

var DeleteAllResult_Io_DEFAULT *IOError

func (p *DeleteAllResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DeleteAllResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteAllResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteAllResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAll_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllResult(%+v)", *p)
}

type DeleteAllTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Column     Text            `thrift:"column,3" json:"column"`
	Timestamp  int64           `thrift:"timestamp,4" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewDeleteAllTsArgs() *DeleteAllTsArgs {
	return &DeleteAllTsArgs{}
}

func (p *DeleteAllTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *DeleteAllTsArgs) GetRow() Text {
	return p.Row
}

func (p *DeleteAllTsArgs) GetColumn() Text {
	return p.Column
}

func (p *DeleteAllTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *DeleteAllTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *DeleteAllTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key153 string
		if _key153, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val154 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val154 = temp
		}
		p.Attributes[_key153] = _val154
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *DeleteAllTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsArgs(%+v)", *p)
}

type DeleteAllTsResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDeleteAllTsResult() *DeleteAllTsResult {
	return &DeleteAllTsResult{}
}

var DeleteAllTsResult_Io_DEFAULT *IOError

func (p *DeleteAllTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DeleteAllTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteAllTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteAllTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllTsResult(%+v)", *p)
}

type DeleteAllRowArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Attributes map[string]Text `thrift:"attributes,3" json:"attributes"`
}

func NewDeleteAllRowArgs() *DeleteAllRowArgs {
	return &DeleteAllRowArgs{}
}

func (p *DeleteAllRowArgs) GetTableName() Text {
	return p.TableName
}

func (p *DeleteAllRowArgs) GetRow() Text {
	return p.Row
}

func (p *DeleteAllRowArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *DeleteAllRowArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllRowArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key155 string
		if _key155, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val156 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val156 = temp
		}
		p.Attributes[_key155] = _val156
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllRowArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowArgs(%+v)", *p)
}

type DeleteAllRowResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDeleteAllRowResult() *DeleteAllRowResult {
	return &DeleteAllRowResult{}
}

var DeleteAllRowResult_Io_DEFAULT *IOError

func (p *DeleteAllRowResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DeleteAllRowResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteAllRowResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteAllRowResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllRowResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRow_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowResult(%+v)", *p)
}

type IncrementArgs struct {
	Increment *TIncrement `thrift:"increment,1" json:"increment"`
}

func NewIncrementArgs() *IncrementArgs {
	return &IncrementArgs{}
}

var IncrementArgs_Increment_DEFAULT *TIncrement

func (p *IncrementArgs) GetIncrement() *TIncrement {
	if !p.IsSetIncrement() {
		return IncrementArgs_Increment_DEFAULT
	}
	return p.Increment
}
func (p *IncrementArgs) IsSetIncrement() bool {
	return p.Increment != nil
}

func (p *IncrementArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Increment = &TIncrement{}
	if err := p.Increment.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Increment, err)
	}
	return nil
}

func (p *IncrementArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("increment", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:increment: %s", p, err)
	}
	if err := p.Increment.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Increment, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:increment: %s", p, err)
	}
	return err
}

func (p *IncrementArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementArgs(%+v)", *p)
}

type IncrementResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewIncrementResult() *IncrementResult {
	return &IncrementResult{}
}

var IncrementResult_Io_DEFAULT *IOError

func (p *IncrementResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return IncrementResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IncrementResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IncrementResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("increment_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementResult(%+v)", *p)
}

type IncrementRowsArgs struct {
	Increments []*TIncrement `thrift:"increments,1" json:"increments"`
}

func NewIncrementRowsArgs() *IncrementRowsArgs {
	return &IncrementRowsArgs{}
}

func (p *IncrementRowsArgs) GetIncrements() []*TIncrement {
	return p.Increments
}
func (p *IncrementRowsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsArgs) ReadField1(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TIncrement, 0, size)
	p.Increments = tSlice
	for i := 0; i < size; i++ {
		_elem157 := &TIncrement{}
		if err := _elem157.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem157, err)
		}
		p.Increments = append(p.Increments, _elem157)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *IncrementRowsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("increments", thrift.LIST, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:increments: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Increments)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Increments {
		if err := v.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", v, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:increments: %s", p, err)
	}
	return err
}

func (p *IncrementRowsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsArgs(%+v)", *p)
}

type IncrementRowsResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewIncrementRowsResult() *IncrementRowsResult {
	return &IncrementRowsResult{}
}

var IncrementRowsResult_Io_DEFAULT *IOError

func (p *IncrementRowsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return IncrementRowsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *IncrementRowsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *IncrementRowsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *IncrementRowsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *IncrementRowsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("incrementRows_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *IncrementRowsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *IncrementRowsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("IncrementRowsResult(%+v)", *p)
}

type DeleteAllRowTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Row        Text            `thrift:"row,2" json:"row"`
	Timestamp  int64           `thrift:"timestamp,3" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewDeleteAllRowTsArgs() *DeleteAllRowTsArgs {
	return &DeleteAllRowTsArgs{}
}

func (p *DeleteAllRowTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *DeleteAllRowTsArgs) GetRow() Text {
	return p.Row
}

func (p *DeleteAllRowTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *DeleteAllRowTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *DeleteAllRowTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *DeleteAllRowTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key158 string
		if _key158, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val159 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val159 = temp
		}
		p.Attributes[_key158] = _val159
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:timestamp: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *DeleteAllRowTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsArgs(%+v)", *p)
}

type DeleteAllRowTsResult struct {
	Io *IOError `thrift:"io,1" json:"io"`
}

func NewDeleteAllRowTsResult() *DeleteAllRowTsResult {
	return &DeleteAllRowTsResult{}
}

var DeleteAllRowTsResult_Io_DEFAULT *IOError

func (p *DeleteAllRowTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return DeleteAllRowTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *DeleteAllRowTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *DeleteAllRowTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("deleteAllRowTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *DeleteAllRowTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *DeleteAllRowTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("DeleteAllRowTsResult(%+v)", *p)
}

type ScannerOpenWithScanArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	Scan       *TScan          `thrift:"scan,2" json:"scan"`
	Attributes map[string]Text `thrift:"attributes,3" json:"attributes"`
}

func NewScannerOpenWithScanArgs() *ScannerOpenWithScanArgs {
	return &ScannerOpenWithScanArgs{}
}

func (p *ScannerOpenWithScanArgs) GetTableName() Text {
	return p.TableName
}

var ScannerOpenWithScanArgs_Scan_DEFAULT *TScan

func (p *ScannerOpenWithScanArgs) GetScan() *TScan {
	if !p.IsSetScan() {
		return ScannerOpenWithScanArgs_Scan_DEFAULT
	}
	return p.Scan
}

func (p *ScannerOpenWithScanArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenWithScanArgs) IsSetScan() bool {
	return p.Scan != nil
}

func (p *ScannerOpenWithScanArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField2(iprot thrift.TProtocol) error {
	p.Scan = &TScan{}
	if err := p.Scan.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Scan, err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) ReadField3(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key160 string
		if _key160, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val161 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val161 = temp
		}
		p.Attributes[_key160] = _val161
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("scan", thrift.STRUCT, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:scan: %s", p, err)
	}
	if err := p.Scan.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Scan, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:scan: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithScanArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithScanArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanArgs(%+v)", *p)
}

type ScannerOpenWithScanResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenWithScanResult() *ScannerOpenWithScanResult {
	return &ScannerOpenWithScanResult{}
}

var ScannerOpenWithScanResult_Success_DEFAULT ScannerID

func (p *ScannerOpenWithScanResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenWithScanResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenWithScanResult_Io_DEFAULT *IOError

func (p *ScannerOpenWithScanResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenWithScanResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenWithScanResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenWithScanResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenWithScanResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenWithScanResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithScan_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithScanResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithScanResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithScanResult(%+v)", *p)
}

type ScannerOpenArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	StartRow   Text            `thrift:"startRow,2" json:"startRow"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Attributes map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewScannerOpenArgs() *ScannerOpenArgs {
	return &ScannerOpenArgs{}
}

func (p *ScannerOpenArgs) GetTableName() Text {
	return p.TableName
}

func (p *ScannerOpenArgs) GetStartRow() Text {
	return p.StartRow
}

func (p *ScannerOpenArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *ScannerOpenArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem162 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem162 = temp
		}
		p.Columns = append(p.Columns, _elem162)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key163 string
		if _key163, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val164 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val164 = temp
		}
		p.Attributes[_key163] = _val164
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartRow); err != nil {
		return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenArgs(%+v)", *p)
}

type ScannerOpenResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenResult() *ScannerOpenResult {
	return &ScannerOpenResult{}
}

var ScannerOpenResult_Success_DEFAULT ScannerID

func (p *ScannerOpenResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenResult_Io_DEFAULT *IOError

func (p *ScannerOpenResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpen_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenResult(%+v)", *p)
}

type ScannerOpenWithStopArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	StartRow   Text            `thrift:"startRow,2" json:"startRow"`
	StopRow    Text            `thrift:"stopRow,3" json:"stopRow"`
	Columns    [][]byte        `thrift:"columns,4" json:"columns"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewScannerOpenWithStopArgs() *ScannerOpenWithStopArgs {
	return &ScannerOpenWithStopArgs{}
}

func (p *ScannerOpenWithStopArgs) GetTableName() Text {
	return p.TableName
}

func (p *ScannerOpenWithStopArgs) GetStartRow() Text {
	return p.StartRow
}

func (p *ScannerOpenWithStopArgs) GetStopRow() Text {
	return p.StopRow
}

func (p *ScannerOpenWithStopArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *ScannerOpenWithStopArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenWithStopArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.StopRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem165 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem165 = temp
		}
		p.Columns = append(p.Columns, _elem165)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key166 string
		if _key166, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val167 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val167 = temp
		}
		p.Attributes[_key166] = _val167
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartRow); err != nil {
		return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("stopRow", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StopRow); err != nil {
		return fmt.Errorf("%T.stopRow (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopArgs(%+v)", *p)
}

type ScannerOpenWithStopResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenWithStopResult() *ScannerOpenWithStopResult {
	return &ScannerOpenWithStopResult{}
}

var ScannerOpenWithStopResult_Success_DEFAULT ScannerID

func (p *ScannerOpenWithStopResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenWithStopResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenWithStopResult_Io_DEFAULT *IOError

func (p *ScannerOpenWithStopResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenWithStopResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenWithStopResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenWithStopResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenWithStopResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenWithStopResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStop_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopResult(%+v)", *p)
}

type ScannerOpenWithPrefixArgs struct {
	TableName      Text            `thrift:"tableName,1" json:"tableName"`
	StartAndPrefix Text            `thrift:"startAndPrefix,2" json:"startAndPrefix"`
	Columns        [][]byte        `thrift:"columns,3" json:"columns"`
	Attributes     map[string]Text `thrift:"attributes,4" json:"attributes"`
}

func NewScannerOpenWithPrefixArgs() *ScannerOpenWithPrefixArgs {
	return &ScannerOpenWithPrefixArgs{}
}

func (p *ScannerOpenWithPrefixArgs) GetTableName() Text {
	return p.TableName
}

func (p *ScannerOpenWithPrefixArgs) GetStartAndPrefix() Text {
	return p.StartAndPrefix
}

func (p *ScannerOpenWithPrefixArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *ScannerOpenWithPrefixArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenWithPrefixArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartAndPrefix = temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem168 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem168 = temp
		}
		p.Columns = append(p.Columns, _elem168)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) ReadField4(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key169 string
		if _key169, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val170 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val170 = temp
		}
		p.Attributes[_key169] = _val170
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("startAndPrefix", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:startAndPrefix: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartAndPrefix); err != nil {
		return fmt.Errorf("%T.startAndPrefix (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:startAndPrefix: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithPrefixArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixArgs(%+v)", *p)
}

type ScannerOpenWithPrefixResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenWithPrefixResult() *ScannerOpenWithPrefixResult {
	return &ScannerOpenWithPrefixResult{}
}

var ScannerOpenWithPrefixResult_Success_DEFAULT ScannerID

func (p *ScannerOpenWithPrefixResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenWithPrefixResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenWithPrefixResult_Io_DEFAULT *IOError

func (p *ScannerOpenWithPrefixResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenWithPrefixResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenWithPrefixResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenWithPrefixResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenWithPrefixResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithPrefix_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithPrefixResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithPrefixResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithPrefixResult(%+v)", *p)
}

type ScannerOpenTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	StartRow   Text            `thrift:"startRow,2" json:"startRow"`
	Columns    [][]byte        `thrift:"columns,3" json:"columns"`
	Timestamp  int64           `thrift:"timestamp,4" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,5" json:"attributes"`
}

func NewScannerOpenTsArgs() *ScannerOpenTsArgs {
	return &ScannerOpenTsArgs{}
}

func (p *ScannerOpenTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *ScannerOpenTsArgs) GetStartRow() Text {
	return p.StartRow
}

func (p *ScannerOpenTsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *ScannerOpenTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *ScannerOpenTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField3(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem171 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem171 = temp
		}
		p.Columns = append(p.Columns, _elem171)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField4(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 4: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenTsArgs) ReadField5(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key172 string
		if _key172, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val173 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val173 = temp
		}
		p.Attributes[_key172] = _val173
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartRow); err != nil {
		return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:columns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (4) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsArgs(%+v)", *p)
}

type ScannerOpenTsResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenTsResult() *ScannerOpenTsResult {
	return &ScannerOpenTsResult{}
}

var ScannerOpenTsResult_Success_DEFAULT ScannerID

func (p *ScannerOpenTsResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenTsResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenTsResult_Io_DEFAULT *IOError

func (p *ScannerOpenTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenTsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenTsResult(%+v)", *p)
}

type ScannerOpenWithStopTsArgs struct {
	TableName  Text            `thrift:"tableName,1" json:"tableName"`
	StartRow   Text            `thrift:"startRow,2" json:"startRow"`
	StopRow    Text            `thrift:"stopRow,3" json:"stopRow"`
	Columns    [][]byte        `thrift:"columns,4" json:"columns"`
	Timestamp  int64           `thrift:"timestamp,5" json:"timestamp"`
	Attributes map[string]Text `thrift:"attributes,6" json:"attributes"`
}

func NewScannerOpenWithStopTsArgs() *ScannerOpenWithStopTsArgs {
	return &ScannerOpenWithStopTsArgs{}
}

func (p *ScannerOpenWithStopTsArgs) GetTableName() Text {
	return p.TableName
}

func (p *ScannerOpenWithStopTsArgs) GetStartRow() Text {
	return p.StartRow
}

func (p *ScannerOpenWithStopTsArgs) GetStopRow() Text {
	return p.StopRow
}

func (p *ScannerOpenWithStopTsArgs) GetColumns() [][]byte {
	return p.Columns
}

func (p *ScannerOpenWithStopTsArgs) GetTimestamp() int64 {
	return p.Timestamp
}

func (p *ScannerOpenWithStopTsArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *ScannerOpenWithStopTsArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 4:
			if err := p.ReadField4(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.StartRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.StopRow = temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField4(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([][]byte, 0, size)
	p.Columns = tSlice
	for i := 0; i < size; i++ {
		var _elem174 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_elem174 = temp
		}
		p.Columns = append(p.Columns, _elem174)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI64(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		p.Timestamp = v
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) ReadField6(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key175 string
		if _key175, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val176 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val176 = temp
		}
		p.Attributes[_key175] = _val176
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField4(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("startRow", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:startRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StartRow); err != nil {
		return fmt.Errorf("%T.startRow (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:startRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("stopRow", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:stopRow: %s", p, err)
	}
	if err := oprot.WriteBinary(p.StopRow); err != nil {
		return fmt.Errorf("%T.stopRow (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:stopRow: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField4(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("columns", thrift.LIST, 4); err != nil {
		return fmt.Errorf("%T write field begin error 4:columns: %s", p, err)
	}
	if err := oprot.WriteListBegin(thrift.STRING, len(p.Columns)); err != nil {
		return fmt.Errorf("error writing list begin: %s", err)
	}
	for _, v := range p.Columns {
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteListEnd(); err != nil {
		return fmt.Errorf("error writing list end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 4:columns: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("timestamp", thrift.I64, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:timestamp: %s", p, err)
	}
	if err := oprot.WriteI64(int64(p.Timestamp)); err != nil {
		return fmt.Errorf("%T.timestamp (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:timestamp: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:attributes: %s", p, err)
	}
	return err
}

func (p *ScannerOpenWithStopTsArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsArgs(%+v)", *p)
}

type ScannerOpenWithStopTsResult struct {
	Success *ScannerID `thrift:"success,0" json:"success"`
	Io      *IOError   `thrift:"io,1" json:"io"`
}

func NewScannerOpenWithStopTsResult() *ScannerOpenWithStopTsResult {
	return &ScannerOpenWithStopTsResult{}
}

var ScannerOpenWithStopTsResult_Success_DEFAULT ScannerID

func (p *ScannerOpenWithStopTsResult) GetSuccess() ScannerID {
	if !p.IsSetSuccess() {
		return ScannerOpenWithStopTsResult_Success_DEFAULT
	}
	return *p.Success
}

var ScannerOpenWithStopTsResult_Io_DEFAULT *IOError

func (p *ScannerOpenWithStopTsResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerOpenWithStopTsResult_Io_DEFAULT
	}
	return p.Io
}
func (p *ScannerOpenWithStopTsResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerOpenWithStopTsResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerOpenWithStopTsResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		temp := ScannerID(v)
		p.Success = &temp
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerOpenWithStopTs_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerOpenWithStopTsResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.I32, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteI32(int32(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerOpenWithStopTsResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerOpenWithStopTsResult(%+v)", *p)
}

type ScannerGetArgs struct {
	Id ScannerID `thrift:"id,1" json:"id"`
}

func NewScannerGetArgs() *ScannerGetArgs {
	return &ScannerGetArgs{}
}

func (p *ScannerGetArgs) GetId() ScannerID {
	return p.Id
}
func (p *ScannerGetArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerGetArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetArgs(%+v)", *p)
}

type ScannerGetResult struct {
	Success []*TRowResult_   `thrift:"success,0" json:"success"`
	Io      *IOError         `thrift:"io,1" json:"io"`
	Ia      *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewScannerGetResult() *ScannerGetResult {
	return &ScannerGetResult{}
}

var ScannerGetResult_Success_DEFAULT []*TRowResult_

func (p *ScannerGetResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var ScannerGetResult_Io_DEFAULT *IOError

func (p *ScannerGetResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerGetResult_Io_DEFAULT
	}
	return p.Io
}

var ScannerGetResult_Ia_DEFAULT *IllegalArgument

func (p *ScannerGetResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return ScannerGetResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *ScannerGetResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerGetResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerGetResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *ScannerGetResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem177 := &TRowResult_{}
		if err := _elem177.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem177, err)
		}
		p.Success = append(p.Success, _elem177)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerGetResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerGetResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGet_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetResult(%+v)", *p)
}

type ScannerGetListArgs struct {
	Id     ScannerID `thrift:"id,1" json:"id"`
	NbRows int32     `thrift:"nbRows,2" json:"nbRows"`
}

func NewScannerGetListArgs() *ScannerGetListArgs {
	return &ScannerGetListArgs{}
}

func (p *ScannerGetListArgs) GetId() ScannerID {
	return p.Id
}

func (p *ScannerGetListArgs) GetNbRows() int32 {
	return p.NbRows
}
func (p *ScannerGetListArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerGetListArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		p.NbRows = v
	}
	return nil
}

func (p *ScannerGetListArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("nbRows", thrift.I32, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:nbRows: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.NbRows)); err != nil {
		return fmt.Errorf("%T.nbRows (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:nbRows: %s", p, err)
	}
	return err
}

func (p *ScannerGetListArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListArgs(%+v)", *p)
}

type ScannerGetListResult struct {
	Success []*TRowResult_   `thrift:"success,0" json:"success"`
	Io      *IOError         `thrift:"io,1" json:"io"`
	Ia      *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewScannerGetListResult() *ScannerGetListResult {
	return &ScannerGetListResult{}
}

var ScannerGetListResult_Success_DEFAULT []*TRowResult_

func (p *ScannerGetListResult) GetSuccess() []*TRowResult_ {
	return p.Success
}

var ScannerGetListResult_Io_DEFAULT *IOError

func (p *ScannerGetListResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerGetListResult_Io_DEFAULT
	}
	return p.Io
}

var ScannerGetListResult_Ia_DEFAULT *IllegalArgument

func (p *ScannerGetListResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return ScannerGetListResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *ScannerGetListResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *ScannerGetListResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerGetListResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *ScannerGetListResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TRowResult_, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem178 := &TRowResult_{}
		if err := _elem178.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem178, err)
		}
		p.Success = append(p.Success, _elem178)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerGetListResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerGetListResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerGetList_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerGetListResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerGetListResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerGetListResult(%+v)", *p)
}

type ScannerCloseArgs struct {
	Id ScannerID `thrift:"id,1" json:"id"`
}

func NewScannerCloseArgs() *ScannerCloseArgs {
	return &ScannerCloseArgs{}
}

func (p *ScannerCloseArgs) GetId() ScannerID {
	return p.Id
}
func (p *ScannerCloseArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadI32(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := ScannerID(v)
		p.Id = temp
	}
	return nil
}

func (p *ScannerCloseArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("id", thrift.I32, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:id: %s", p, err)
	}
	if err := oprot.WriteI32(int32(p.Id)); err != nil {
		return fmt.Errorf("%T.id (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:id: %s", p, err)
	}
	return err
}

func (p *ScannerCloseArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseArgs(%+v)", *p)
}

type ScannerCloseResult struct {
	Io *IOError         `thrift:"io,1" json:"io"`
	Ia *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewScannerCloseResult() *ScannerCloseResult {
	return &ScannerCloseResult{}
}

var ScannerCloseResult_Io_DEFAULT *IOError

func (p *ScannerCloseResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return ScannerCloseResult_Io_DEFAULT
	}
	return p.Io
}

var ScannerCloseResult_Ia_DEFAULT *IllegalArgument

func (p *ScannerCloseResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return ScannerCloseResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *ScannerCloseResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *ScannerCloseResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *ScannerCloseResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *ScannerCloseResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *ScannerCloseResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *ScannerCloseResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("scannerClose_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *ScannerCloseResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *ScannerCloseResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("ScannerCloseResult(%+v)", *p)
}

type GetRowOrBeforeArgs struct {
	TableName Text `thrift:"tableName,1" json:"tableName"`
	Row       Text `thrift:"row,2" json:"row"`
	Family    Text `thrift:"family,3" json:"family"`
}

func NewGetRowOrBeforeArgs() *GetRowOrBeforeArgs {
	return &GetRowOrBeforeArgs{}
}

func (p *GetRowOrBeforeArgs) GetTableName() Text {
	return p.TableName
}

func (p *GetRowOrBeforeArgs) GetRow() Text {
	return p.Row
}

func (p *GetRowOrBeforeArgs) GetFamily() Text {
	return p.Family
}
func (p *GetRowOrBeforeArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Family = temp
	}
	return nil
}

func (p *GetRowOrBeforeArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *GetRowOrBeforeArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("family", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:family: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Family); err != nil {
		return fmt.Errorf("%T.family (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:family: %s", p, err)
	}
	return err
}

func (p *GetRowOrBeforeArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeArgs(%+v)", *p)
}

type GetRowOrBeforeResult struct {
	Success []*TCell `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewGetRowOrBeforeResult() *GetRowOrBeforeResult {
	return &GetRowOrBeforeResult{}
}

var GetRowOrBeforeResult_Success_DEFAULT []*TCell

func (p *GetRowOrBeforeResult) GetSuccess() []*TCell {
	return p.Success
}

var GetRowOrBeforeResult_Io_DEFAULT *IOError

func (p *GetRowOrBeforeResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRowOrBeforeResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRowOrBeforeResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRowOrBeforeResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRowOrBeforeResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem179 := &TCell{}
		if err := _elem179.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem179, err)
		}
		p.Success = append(p.Success, _elem179)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRowOrBefore_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRowOrBeforeResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRowOrBeforeResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRowOrBeforeResult(%+v)", *p)
}

type GetRegionInfoArgs struct {
	Row Text `thrift:"row,1" json:"row"`
}

func NewGetRegionInfoArgs() *GetRegionInfoArgs {
	return &GetRegionInfoArgs{}
}

func (p *GetRegionInfoArgs) GetRow() Text {
	return p.Row
}
func (p *GetRegionInfoArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *GetRegionInfoArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:row: %s", p, err)
	}
	return err
}

func (p *GetRegionInfoArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoArgs(%+v)", *p)
}

type GetRegionInfoResult struct {
	Success *TRegionInfo `thrift:"success,0" json:"success"`
	Io      *IOError     `thrift:"io,1" json:"io"`
}

func NewGetRegionInfoResult() *GetRegionInfoResult {
	return &GetRegionInfoResult{}
}

var GetRegionInfoResult_Success_DEFAULT *TRegionInfo

func (p *GetRegionInfoResult) GetSuccess() *TRegionInfo {
	if !p.IsSetSuccess() {
		return GetRegionInfoResult_Success_DEFAULT
	}
	return p.Success
}

var GetRegionInfoResult_Io_DEFAULT *IOError

func (p *GetRegionInfoResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return GetRegionInfoResult_Io_DEFAULT
	}
	return p.Io
}
func (p *GetRegionInfoResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *GetRegionInfoResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *GetRegionInfoResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *GetRegionInfoResult) ReadField0(iprot thrift.TProtocol) error {
	p.Success = &TRegionInfo{}
	if err := p.Success.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Success, err)
	}
	return nil
}

func (p *GetRegionInfoResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *GetRegionInfoResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("getRegionInfo_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *GetRegionInfoResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.STRUCT, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := p.Success.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Success, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *GetRegionInfoResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("GetRegionInfoResult(%+v)", *p)
}

type AppendArgs struct {
	Append *TAppend `thrift:"append,1" json:"append"`
}

func NewAppendArgs() *AppendArgs {
	return &AppendArgs{}
}

var AppendArgs_Append_DEFAULT *TAppend

func (p *AppendArgs) GetAppend() *TAppend {
	if !p.IsSetAppend() {
		return AppendArgs_Append_DEFAULT
	}
	return p.Append
}
func (p *AppendArgs) IsSetAppend() bool {
	return p.Append != nil
}

func (p *AppendArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendArgs) ReadField1(iprot thrift.TProtocol) error {
	p.Append = &TAppend{}
	if err := p.Append.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Append, err)
	}
	return nil
}

func (p *AppendArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("append", thrift.STRUCT, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:append: %s", p, err)
	}
	if err := p.Append.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Append, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:append: %s", p, err)
	}
	return err
}

func (p *AppendArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendArgs(%+v)", *p)
}

type AppendResult struct {
	Success []*TCell `thrift:"success,0" json:"success"`
	Io      *IOError `thrift:"io,1" json:"io"`
}

func NewAppendResult() *AppendResult {
	return &AppendResult{}
}

var AppendResult_Success_DEFAULT []*TCell

func (p *AppendResult) GetSuccess() []*TCell {
	return p.Success
}

var AppendResult_Io_DEFAULT *IOError

func (p *AppendResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return AppendResult_Io_DEFAULT
	}
	return p.Io
}
func (p *AppendResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *AppendResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *AppendResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *AppendResult) ReadField0(iprot thrift.TProtocol) error {
	_, size, err := iprot.ReadListBegin()
	if err != nil {
		return fmt.Errorf("error reading list begin: %s", err)
	}
	tSlice := make([]*TCell, 0, size)
	p.Success = tSlice
	for i := 0; i < size; i++ {
		_elem186 := &TCell{}
		if err := _elem186.Read(iprot); err != nil {
			return fmt.Errorf("%T error reading struct: %s", _elem186, err)
		}
		p.Success = append(p.Success, _elem186)
	}
	if err := iprot.ReadListEnd(); err != nil {
		return fmt.Errorf("error reading list end: %s", err)
	}
	return nil
}

func (p *AppendResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *AppendResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("append_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *AppendResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.LIST, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteListBegin(thrift.STRUCT, len(p.Success)); err != nil {
			return fmt.Errorf("error writing list begin: %s", err)
		}
		for _, v := range p.Success {
			if err := v.Write(oprot); err != nil {
				return fmt.Errorf("%T error writing struct: %s", v, err)
			}
		}
		if err := oprot.WriteListEnd(); err != nil {
			return fmt.Errorf("error writing list end: %s", err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *AppendResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("AppendResult(%+v)", *p)
}

type CheckAndPutArgs struct {
	TableName Text `thrift:"tableName,1" json:"tableName"`
	Row       Text `thrift:"row,2" json:"row"`
	Column    Text `thrift:"column,3" json:"column"`
	// unused field # 4
	Value      Text            `thrift:"value,5" json:"value"`
	Mput       *Mutation       `thrift:"mput,6" json:"mput"`
	Attributes map[string]Text `thrift:"attributes,7" json:"attributes"`
}

func NewCheckAndPutArgs() *CheckAndPutArgs {
	return &CheckAndPutArgs{}
}

func (p *CheckAndPutArgs) GetTableName() Text {
	return p.TableName
}

func (p *CheckAndPutArgs) GetRow() Text {
	return p.Row
}

func (p *CheckAndPutArgs) GetColumn() Text {
	return p.Column
}

func (p *CheckAndPutArgs) GetValue() Text {
	return p.Value
}

var CheckAndPutArgs_Mput_DEFAULT *Mutation

func (p *CheckAndPutArgs) GetMput() *Mutation {
	if !p.IsSetMput() {
		return CheckAndPutArgs_Mput_DEFAULT
	}
	return p.Mput
}

func (p *CheckAndPutArgs) GetAttributes() map[string]Text {
	return p.Attributes
}
func (p *CheckAndPutArgs) IsSetMput() bool {
	return p.Mput != nil
}

func (p *CheckAndPutArgs) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		case 3:
			if err := p.ReadField3(iprot); err != nil {
				return err
			}
		case 5:
			if err := p.ReadField5(iprot); err != nil {
				return err
			}
		case 6:
			if err := p.ReadField6(iprot); err != nil {
				return err
			}
		case 7:
			if err := p.ReadField7(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField1(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 1: %s", err)
	} else {
		temp := Text(v)
		p.TableName = temp
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField2(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 2: %s", err)
	} else {
		temp := Text(v)
		p.Row = temp
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField3(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 3: %s", err)
	} else {
		temp := Text(v)
		p.Column = temp
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField5(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBinary(); err != nil {
		return fmt.Errorf("error reading field 5: %s", err)
	} else {
		temp := Text(v)
		p.Value = temp
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField6(iprot thrift.TProtocol) error {
	p.Mput = &Mutation{
		WriteToWAL: true,
	}
	if err := p.Mput.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Mput, err)
	}
	return nil
}

func (p *CheckAndPutArgs) ReadField7(iprot thrift.TProtocol) error {
	_, _, size, err := iprot.ReadMapBegin()
	if err != nil {
		return fmt.Errorf("error reading map begin: %s", err)
	}
	tMap := make(map[string]Text, size)
	p.Attributes = tMap
	for i := 0; i < size; i++ {
		var _key187 string
		if _key187, err = iprot.ReadString(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		}
		var _val188 Text
		if v, err := iprot.ReadBinary(); err != nil {
			return fmt.Errorf("error reading field 0: %s", err)
		} else {
			temp := Text(v)
			_val188 = temp
		}
		p.Attributes[_key187] = _val188
	}
	if err := iprot.ReadMapEnd(); err != nil {
		return fmt.Errorf("error reading map end: %s", err)
	}
	return nil
}

func (p *CheckAndPutArgs) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_args"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := p.writeField3(oprot); err != nil {
		return err
	}
	if err := p.writeField5(oprot); err != nil {
		return err
	}
	if err := p.writeField6(oprot); err != nil {
		return err
	}
	if err := p.writeField7(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutArgs) writeField1(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("tableName", thrift.STRING, 1); err != nil {
		return fmt.Errorf("%T write field begin error 1:tableName: %s", p, err)
	}
	if err := oprot.WriteBinary(p.TableName); err != nil {
		return fmt.Errorf("%T.tableName (1) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 1:tableName: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField2(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("row", thrift.STRING, 2); err != nil {
		return fmt.Errorf("%T write field begin error 2:row: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Row); err != nil {
		return fmt.Errorf("%T.row (2) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 2:row: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField3(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("column", thrift.STRING, 3); err != nil {
		return fmt.Errorf("%T write field begin error 3:column: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Column); err != nil {
		return fmt.Errorf("%T.column (3) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 3:column: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField5(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("value", thrift.STRING, 5); err != nil {
		return fmt.Errorf("%T write field begin error 5:value: %s", p, err)
	}
	if err := oprot.WriteBinary(p.Value); err != nil {
		return fmt.Errorf("%T.value (5) field write error: %s", p, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 5:value: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField6(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("mput", thrift.STRUCT, 6); err != nil {
		return fmt.Errorf("%T write field begin error 6:mput: %s", p, err)
	}
	if err := p.Mput.Write(oprot); err != nil {
		return fmt.Errorf("%T error writing struct: %s", p.Mput, err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 6:mput: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) writeField7(oprot thrift.TProtocol) (err error) {
	if err := oprot.WriteFieldBegin("attributes", thrift.MAP, 7); err != nil {
		return fmt.Errorf("%T write field begin error 7:attributes: %s", p, err)
	}
	if err := oprot.WriteMapBegin(thrift.STRING, thrift.STRING, len(p.Attributes)); err != nil {
		return fmt.Errorf("error writing map begin: %s", err)
	}
	for k, v := range p.Attributes {
		if err := oprot.WriteString(string(k)); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
		if err := oprot.WriteBinary(v); err != nil {
			return fmt.Errorf("%T. (0) field write error: %s", p, err)
		}
	}
	if err := oprot.WriteMapEnd(); err != nil {
		return fmt.Errorf("error writing map end: %s", err)
	}
	if err := oprot.WriteFieldEnd(); err != nil {
		return fmt.Errorf("%T write field end error 7:attributes: %s", p, err)
	}
	return err
}

func (p *CheckAndPutArgs) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutArgs(%+v)", *p)
}

type CheckAndPutResult struct {
	Success *bool            `thrift:"success,0" json:"success"`
	Io      *IOError         `thrift:"io,1" json:"io"`
	Ia      *IllegalArgument `thrift:"ia,2" json:"ia"`
}

func NewCheckAndPutResult() *CheckAndPutResult {
	return &CheckAndPutResult{}
}

var CheckAndPutResult_Success_DEFAULT bool

func (p *CheckAndPutResult) GetSuccess() bool {
	if !p.IsSetSuccess() {
		return CheckAndPutResult_Success_DEFAULT
	}
	return *p.Success
}

var CheckAndPutResult_Io_DEFAULT *IOError

func (p *CheckAndPutResult) GetIo() *IOError {
	if !p.IsSetIo() {
		return CheckAndPutResult_Io_DEFAULT
	}
	return p.Io
}

var CheckAndPutResult_Ia_DEFAULT *IllegalArgument

func (p *CheckAndPutResult) GetIa() *IllegalArgument {
	if !p.IsSetIa() {
		return CheckAndPutResult_Ia_DEFAULT
	}
	return p.Ia
}
func (p *CheckAndPutResult) IsSetSuccess() bool {
	return p.Success != nil
}

func (p *CheckAndPutResult) IsSetIo() bool {
	return p.Io != nil
}

func (p *CheckAndPutResult) IsSetIa() bool {
	return p.Ia != nil
}

func (p *CheckAndPutResult) Read(iprot thrift.TProtocol) error {
	if _, err := iprot.ReadStructBegin(); err != nil {
		return fmt.Errorf("%T read error: %s", p, err)
	}
	for {
		_, fieldTypeId, fieldId, err := iprot.ReadFieldBegin()
		if err != nil {
			return fmt.Errorf("%T field %d read error: %s", p, fieldId, err)
		}
		if fieldTypeId == thrift.STOP {
			break
		}
		switch fieldId {
		case 0:
			if err := p.ReadField0(iprot); err != nil {
				return err
			}
		case 1:
			if err := p.ReadField1(iprot); err != nil {
				return err
			}
		case 2:
			if err := p.ReadField2(iprot); err != nil {
				return err
			}
		default:
			if err := iprot.Skip(fieldTypeId); err != nil {
				return err
			}
		}
		if err := iprot.ReadFieldEnd(); err != nil {
			return err
		}
	}
	if err := iprot.ReadStructEnd(); err != nil {
		return fmt.Errorf("%T read struct end error: %s", p, err)
	}
	return nil
}

func (p *CheckAndPutResult) ReadField0(iprot thrift.TProtocol) error {
	if v, err := iprot.ReadBool(); err != nil {
		return fmt.Errorf("error reading field 0: %s", err)
	} else {
		p.Success = &v
	}
	return nil
}

func (p *CheckAndPutResult) ReadField1(iprot thrift.TProtocol) error {
	p.Io = &IOError{}
	if err := p.Io.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Io, err)
	}
	return nil
}

func (p *CheckAndPutResult) ReadField2(iprot thrift.TProtocol) error {
	p.Ia = &IllegalArgument{}
	if err := p.Ia.Read(iprot); err != nil {
		return fmt.Errorf("%T error reading struct: %s", p.Ia, err)
	}
	return nil
}

func (p *CheckAndPutResult) Write(oprot thrift.TProtocol) error {
	if err := oprot.WriteStructBegin("checkAndPut_result"); err != nil {
		return fmt.Errorf("%T write struct begin error: %s", p, err)
	}
	if err := p.writeField0(oprot); err != nil {
		return err
	}
	if err := p.writeField1(oprot); err != nil {
		return err
	}
	if err := p.writeField2(oprot); err != nil {
		return err
	}
	if err := oprot.WriteFieldStop(); err != nil {
		return fmt.Errorf("write field stop error: %s", err)
	}
	if err := oprot.WriteStructEnd(); err != nil {
		return fmt.Errorf("write struct stop error: %s", err)
	}
	return nil
}

func (p *CheckAndPutResult) writeField0(oprot thrift.TProtocol) (err error) {
	if p.IsSetSuccess() {
		if err := oprot.WriteFieldBegin("success", thrift.BOOL, 0); err != nil {
			return fmt.Errorf("%T write field begin error 0:success: %s", p, err)
		}
		if err := oprot.WriteBool(bool(*p.Success)); err != nil {
			return fmt.Errorf("%T.success (0) field write error: %s", p, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 0:success: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) writeField1(oprot thrift.TProtocol) (err error) {
	if p.IsSetIo() {
		if err := oprot.WriteFieldBegin("io", thrift.STRUCT, 1); err != nil {
			return fmt.Errorf("%T write field begin error 1:io: %s", p, err)
		}
		if err := p.Io.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Io, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 1:io: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) writeField2(oprot thrift.TProtocol) (err error) {
	if p.IsSetIa() {
		if err := oprot.WriteFieldBegin("ia", thrift.STRUCT, 2); err != nil {
			return fmt.Errorf("%T write field begin error 2:ia: %s", p, err)
		}
		if err := p.Ia.Write(oprot); err != nil {
			return fmt.Errorf("%T error writing struct: %s", p.Ia, err)
		}
		if err := oprot.WriteFieldEnd(); err != nil {
			return fmt.Errorf("%T write field end error 2:ia: %s", p, err)
		}
	}
	return err
}

func (p *CheckAndPutResult) String() string {
	if p == nil {
		return "<nil>"
	}
	return fmt.Sprintf("CheckAndPutResult(%+v)", *p)
}
